\section{Proof Development}
\label{sec:mot-dev}

% TODO table with simplified theory languages and the implementation languages, plus a summary of some differences covered in implementation sections

For the sake of this chapter, I will not demonstrate proof development, maintenance, and repair on a C compiler or on an OS microkernel.
Instead, I will start by demonstrating a simple proof development: 
that the list zip function preserves its length.
This is a toy example, but it is worth noting that large proof developments like compilers and microkernels
are often made up of many of these smaller examples built on top of each other.	
The proof assistant that I demonstrate this on is Coq (Section~\ref{sec:mot-coq}), since this is the proof assistant that this work focuses on.

I already briefly introduced the Coq workflow in the introduction.
Here I am going to go into a bit more detail on the example and talk about foundations as relevant to this thesis.
I am not going to teach you all of Coq in this thesis;
good sources for learning Coq from scratch include the books Certified Programming with Dependent Types~\cite{chlipala:cpdt}
and Software Foundations~\cite{software-foundations}.
More about this can also be found in the survey paper.

The introduction mentioned that proofs are written as proof scripts in a high-level language of tactics,
and that those proof scripts compile down to proof terms in a low-level language.
Technically, proofs can be written entirely as proof terms; tactics just make it easier to write proofs and offer abstraction.
We'll get to tactics soon (Section~\ref{sec:tactics}), but let's start with terms (Section~\ref{sec:mot-coq}).

\input{coq}

\input{tactics}


\subsection{The Workflow}
\label{sec:mot-workflow}

Before we can write our small verified program, we need some datatypes and functions that we can find in the Coq standard library (Section~\ref{sec:prelims}).
We can then use these datatypes and functions to write the \lstinline{zip} function and show that it preserves its length (Section~\ref{sec:verif}).

\subsubsection{Preliminaries}
\label{sec:prelims}

To prove that the list zip function preserves its length,
we need the \lstinline{list} datatype and the \lstinline{length} function.
To write the \lstinline{length} function, we need the \lstinline{nat} datatype of unary natural numbers.
All of these can be found in the Coq standard library.

\begin{figure}
\begin{minipage}{0.30\textwidth}
\begin{lstlisting}
Inductive nat :=
| O : nat
| S : nat $\rightarrow$ nat.
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.68\textwidth}
\begin{lstlisting}
nat_rect :
  $\forall$ (P : nat $\rightarrow$ Type),
    P O $\rightarrow$ (* base case *)
    ($\forall$ (n : nat),
      (* inductive case *)
      P n $\rightarrow$ P (S n)) $\rightarrow$
    $\forall$ (n : nat), P n.
\end{lstlisting}
\end{minipage}
\caption{The type of natural numbers \lstinline{nat} in Coq defined inductively by its two constructors (left), and the type of the corresponding eliminator or induction principle \lstinline{nat_rect} that Coq generates (right).}
\label{fig:nat}
\end{figure}

Each of \lstinline{nat} and \lstinline{list} in Gallina is an \textit{inductive type}:
it is defined by its \textit{constructors} (ways of constructing a term with that type).
A \lstinline{nat} (Figure~\ref{fig:nat}, left), for example,
is either \lstinline{0} or the successor \lstinline{S} of another \lstinline{nat};
these are the two constructors of \lstinline{nat}.

Every inductive type in Gallina comes equipped with an \textit{eliminator} or induction principle
that the proof engineer can use to write functions and proofs about the datatype.
For example, the eliminator for \lstinline{nat} (Figure~\ref{fig:nat}, right) is the standard induction principle for natural numbers,
which Coq calls \lstinline{nat_rect}. % TODO footnote about nat_ind, nat_rec, nat_rect
This eliminator states that a statement \lstinline{P} (called the inductive \textit{motive}) about the natural numbers
holds for every number if it holds for \lstinline{O} in the base case and, in the inductive case,
assuming it holds for some \lstinline{n}, it also holds for the successor \lstinline{S n}.

\begin{figure}
\begin{minipage}{0.44\textwidth}
\begin{lstlisting}
Inductive list {T : Type} :=
| nil : list T
| cons :
    T $\rightarrow$ list T $\rightarrow$ list T.
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.54\textwidth}
\begin{lstlisting}
list_rect :
  $\forall$ {T : Type} (P : list T $\rightarrow$ Type),
    P nil $\rightarrow$ (* base case *)
    ($\forall$ (t : T) (tl : list T),
      (* inductive case *)
      P tl $\rightarrow$ P (cons t tl)) $\rightarrow$
    $\forall$ (l : list T), P l.
\end{lstlisting}
\end{minipage}
\caption{The type of polymorphic lists \lstinline{list} in Coq defined inductively by its two constructors (left), and the type of the corresponding eliminator or induction principle \lstinline{list_rect} that Coq generates (right). The curly brace notation means that the type parameter \lstinline{T} is implicit in applications.}
\label{fig:list}
\end{figure}

 % TODO footnote about nat_ind, nat_rec, nat_rect

A \lstinline{list} (Figure~\ref{fig:list}, left) is similar to a \lstinline{nat}, 
but with two differences: \lstinline{list} is polymorphic over some type \lstinline{T} (so we can have a list of natural numbers,
for example, written \lstinline{list nat}), and the second constructor adds a new element of the type \lstinline{T} to the front of the list.
Otherwise, \lstinline{list} also has two constructors, \lstinline{nil} and \lstinline{cons}, where \lstinline{nil} represents the empty list,
and \lstinline{cons} sticks a new element in front of any existing list.
Similarly, the eliminator for \lstinline{list} (Figure~\ref{fig:list}, right) looks like the eliminator for \lstinline{nat} 
but with an argument corresponding to the parameter \lstinline{T} over which \lstinline{list} is polymorphic,
and with an additional argument corresponding to the new element in the inductive case.

One interesting thing about the types of these eliminators \lstinline{list_rect} and \lstinline{nat_rect}
include universal quantification over all inputs, written $\forall$.
Gallina's type system is expressive enough to include universal quantification over inputs---I will explain how
in Section~\ref{sec:mot-theory}.

\begin{figure}
\begin{minipage}{0.42\textwidth}
\begin{lstlisting}
Fixpoint length {T} l :=
  match l with
  | nil => O
  | cons t tl =>
      S (length tl)
  end.
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.54\textwidth}
\begin{lstlisting}
Definition length {T} l :=
  list_rect T (fun _ => nat)
    O
    (fun t tl (length_tl : nat) =>
      S length_tl)
    l.
\end{lstlisting}
\end{minipage}
\caption{The list \lstinline{length} function, defined both by pattern matching and recursion (left) and using the eliminator \lstinline{list_rect} (right).}
\label{fig:length}
\end{figure}

We can use these eliminators to write functions and proofs, like the \lstinline{length} function we will need for our proof development (Figure~\ref{fig:length}, right).
More standard is to write functions using pattern matching and guarded recursion, like the \lstinline{length} function from the Coq standard library (Figure~\ref{fig:length}, left).
Both of these two functions behave the same way, but the function on the left is perhaps a bit easier to understand from a traditional programming background:
the \lstinline{length} of the empty list \lstinline{nil} is \lstinline{0}, and the length of any other list
is just the successor (\lstinline{S}) of the result of recursively calling \lstinline{length} on everything but the first element of the list.
Indeed, \lstinline{list_rect}---like all eliminators in Coq---is just a constant that refers to a function itself defined using pattern matching and guarded recursion.
In fact, eliminators are equally expressive to pattern matching and guarded recursion~\cite{TODO}. % the general translation is hard and Coq sucks at eliminator gen though

For the sake of this thesis, however, I will assume \intro{primitive eliminators}: eliminators that are a part of the core syntax and theory itself,
and that do not reduce to terms that use pattern matching and guarded recursion.
Likewise, when I show Gallina code, I will always use functions that apply eliminators rather than pattern matching, like the \lstinline{length} function from Figure~\ref{fig:length}
on the right.
I remove the \lstinline{Definition} and \lstinline{Fixpoint} keywords, since everything from here on out is a \lstinline{Definition}.
To handle practical code that uses pattern matching and guarded recursion,
I preprocesss the code using a tool by my coauthor Nate Yazdani (more about this later). % TODO make this more formal, can say limitations, can say generates length above, wahtever
In the rest of the paper, I skip this preprocessing step in examples, but I describe it more in the implementation section later.

\subsubsection{List Zip Preserves Length}
\label{sec:verif}

With \lstinline{nat}, \lstinline{list}, and \lstinline{length} defined, we can now write our small verified program.
We start by writing the \lstinline{zip} program, then specify what it means to preserve its length, and then finally
write an interactive proof that shows that specification actually holds.
Coq checks this proof and lets us now that our proof is correct, so our \lstinline{zip} function is verified.

\begin{figure}
\begin{lstlisting}
zip {T$_1$} {T$_2$} (l$_1$ : list T$_1$) (l$_2$ : list T$_2$) : list (T$_1$ * T$_2$) :=
  list_rect (fun _ : list T$_1$ => list T$_2$ $\rightarrow$ list (T$_1$ * T$_2$))
    (fun _ => nil)
    (fun t$_1$ tl$_1$ (zip_tl$_1$ : list T$_2$ $\rightarrow$ list (T$_1$ * T$_2$)) l$_2$ =>
      list_rect (fun _ : list T$_2$ => list (T$_1$ * T$_2$))
        nil
        (fun t$_2$ tl$_2$ (_ : list (T$_1$ * T$_2$)) =>
          cons (t$_1$, t$_2$) (zip_tl$_1$ tl$_2$))
        l$_2$)
    l$_1$
    l$_2$.
\end{lstlisting}
\caption{The list \lstinline{zip} function, taken from an existing tool~\cite{TODO} % TODO hs-to-coq cite
and translated to use eliminators.}
\label{fig:zip}
\end{figure}

\paragraph{Program} The list \lstinline{zip} function is in Figure~\ref{fig:zip}.
It takes as arguments two lists \lstinline{l}$_1$ and \lstinline{l}$_2$ of possibly different types \lstinline{T}$_1$ and \lstinline{T}$_2$, and zips them together into
a list of pairs \lstinline{(T}$_1$\lstinline{ * T}$_2$\lstinline{)}.
For example, if the input lists are: % TODO put this in a figure tbh, like from the slides

\begin{lstlisting}
(* [1; 2; 3; 4] *)
l$_1$ := cons 1 (cons 2 (cons 3 (cons 4 nil))).

(* ["x"; "y"; "z"] *)
l$_2$ := cons "x" (cons "y" (cons "z" nil)).
\end{lstlisting}
then \lstinline{zip} applied to those two lists returns:

\begin{lstlisting}
(* [(1, "x"); (2, "y"); (3, "z")] *)
cons (1, "x") (cons (2, "y") (cons (3, "z") nil)).
\end{lstlisting}
It is worth noting that the implementation of \lstinline{zip} has to make some decision with
what to do with the extra \lstinline{4} at the end---that is, how \lstinline{zip} behaves when the input
lists are different lengths.
The decision that this implementation makes is to just ignore those extra elements.

Otherwise, the implementation is fairly standard.
If \lstinline{l}$_1$ is \lstinline{nil} (base case of the outer induction),
\lstinline{zip} returns \lstinline{nil}.
Otherwise (inductive case of the outer induction),
if \lstinline{l}$_2$ is \lstinline{nil} (base case of the inner induction),
\lstinline{zip} returns \lstinline{nil}.
If \lstinline{l}$_2$ is anything else (inductive case of the inner induction),
\lstinline{zip} combines the first two elements of each list into a pair (\lstinline{(t}$_1$\lstinline{, t}$_2$\lstinline{)}),
then sticks that in front of (using \lstinline{cons}) the result of recursively calling \lstinline{zip} on the tails of each list
(\lstinline{zip_tl}$_1$ \lstinline{tl}$_2$). % TODO a bit hard to understand probably, may need more explanation

\begin{figure}
\begin{lstlisting}
TODO zip_preserves_length, one version
\end{lstlisting}
\caption{TODO}
\label{fig:zip-pres}
\end{figure}

\begin{figure}
\begin{lstlisting}
TODO zip_preserves_length, another version
\end{lstlisting}
\caption{TODO}
\label{fig:zip-pres-alt}
\end{figure}

\paragraph{Specification} Figure~\ref{fig:zip-pres} or Figure~\ref{zip-pres-alt}, note art, stronger and so on, will come back to this.
Also this is where a lot of the power of the language comes in, worth noting.

\begin{figure}
\begin{lstlisting}
TODO zip_preserves_length proof
\end{lstlisting}
\caption{TODO}
\label{fig:zip-pres-proof}
\end{figure}

\paragraph{Proof} 
In Coq, those tactics are in a language called Ltac.
Each tactic is effectively a search procedure for a proof term, given the context and goals at each step of the proof.
Here is one possible proof of \lstinline{zip_preserves_length} using very simple tactics:
\begin{lstlisting}
Lemma zip_length : zip_preserves_length.
Proof.
   intros a b l1.
   induction l1 as [|_ _ IHtl1]; auto.
   induction l2 as [|_ _ IHtl2]; intros H; auto.
   simpl. rewrite IHtl1; auto.
Qed.
\end{lstlisting}
This compiles to the thing we saw before, which then type checks as expected.
But we never have to see the low-level proof term; we can reason about the high-level proof script instead.
% TODO save the better version for later so that we can show how good automation can get around some of the repair stuff
% TODO walk through and so on

Mention decompiler, explain, tease implementation section.





\section*{The Next Era: Proof Engineering for All}

% 2030? could do decades for each of this lol. I guess only if energy
% Do just 2-3 sentences per project.

Proof engineering has come a long way, but it is still accessible mostly to experts, and perhaps the occasional practitioner.
Proof repair has made proof engineering easier for experts, and a bit easier for practitioners.
But there is a lot more that we as a community can do to bring proof engineering to all: not just experts and practitioners,
but also software engineers and potential users from in other domains.

I conclude with a discussion of 12 future project ideas building up to the next era of proof engineering for all.
If any of these ideas inspire you, please work with me to bring them to life.

\subsection*{Experts}

In the future, maintaining proofs ought to be seamless for expert proof engineers.
Ideally, this means technologies---like proof repair---that automate everything but the creative parts of maintenance tasks,
leaving the creativity to the experts.
But the maintenance technologies of the future ought to be accessible across all proof assistants,
to be much more powerful,
and to produce natural proof scripts in the end.

\paragraph{All Proof Assistants}
Proof repair ought to be accessible across all proof assistants.
The techniques from this thesis should be simple to apply to proof assistants with similar foundations to Coq, like Agda,
and potentially Lean.\footnote{Lean assumes an axiom that is incompatible with univalence.
It is not quite clear to me what that assumption would mean for implementing the \toolnamec transformation in Lean.
Everything else should carry over.}
But Isabelle/HOL, for example, lacks proof terms and is based on a classical logic.
One path toward proof repair for Isabelle/HOL may be to reify proof terms using
Isabelle/HOL-Proofs, apply a transformation based on the Transfer~\cite{Huffman2013} package for proof reuse, and then (as in \toolnamec) decompile those terms to automation that does 
not apply Transfer or refer to the old datatype.
Similar approaches may work for other proof assistants.

\paragraph{More Power} 
Proof repair ought to be much more powerful than it is right now.
%For example, the repair tools of the present have only limited support for proof assistant version updates;
%the repair tools of the future ought to run automatically in response to version updates, and ought to support fundamental changes in the proof term
%or proof script language.
The repair tools of the future ought to run automatically in response to proof assistant version updates.
%, and ought to support
%fundamental changes in the proof term or proof script language.
They ought to break down large changes into smaller pieces---perhaps by drawing on work in change and 
dependency management~\cite{873647, Autexier:2010:CMH:1986659.1986663, Celik:2017:IRP:3155562.3155588} to identify changes, then use the factoring transformation
to break those changes into smaller parts.
And they ought to support an even broader and more practical class of changes than they do now,
like arbitrary relations.

\paragraph{Natural Proofs}
Proof repair tools ought to produce repaired proof scripts that are natural for expert proof engineers,
regardless of style.
Toward this end, I have just begun a promising project with \kl{RanDair} and some collaborators at UMass Amherst
on integrating the prototype decompiler with the machine learning proof synthesis tool TacTok~\cite{10.1145/3428299} to rank tactic hints.
Producing more natural proofs than the prototype decompiler using fixed training data seems feasible.
More difficult---but desirable---is to train the decompiler to produce scripts that match the style of the proof engineer using the tool.

\subsection*{Practitioners}

Proof engineering is just starting to reach practitioners, like proof engineers in industry---my proof repair tools have been a small part of that.
Usability has been central to that effort.
Still, usability remains a barrier to bringing not just proof repair tools, but also proof engineering 
more broadly to practitioners.
Some paths to better automation and workflow integration are already clear.
For the rest, I believe that empirical evaluation will hold the answers.

\paragraph{Automation} More search procedures for automatic configuration, e-graphs from PUMPKIN Pi, custom unification heuristics.

\paragraph{Integration} IDE \& CI integration, HCI for repair.

\paragraph{Evaluation} repair challenge, user studies ideas (PUMPKIN PATCH, REPLICA, panel w/ Benjamin Pierce, QED at large). (maybe look for more ideas, this can be merged with integration if need be).

\subsection*{Software Engineers}

Unifying theme: mixed methods verification, or the 2030 vision from Twitter thread. Some examples:

\paragraph{Gradual Verification} A continuum from testing to verification, tools to help with that.

\paragraph{Tool-Assisted Proof Development} Tool-assisted development to follow good design principles for verificattion (James Wilcox conversation, final REPLICA takeaway).

\paragraph{Specification Inference} Analysis to infer specs (TA1).

\subsection*{New Domains}

Unifying theme: collaboration, new abstractions for new domains). Some examples:

\paragraph{Machine Learning} Fairification \& other ML correctness properties. Some stuff here but more.

\paragraph{Cryptography} Lots of stuff here but not thinking broadly enough. What about cryptographic proof systems? ZK and beyond. Recall email thread.

\paragraph{Something Else} Look for more in survey paper, email, DARPA TAs, Twitter. Healthcare perhaps? % https://twitter.com/TaliaRinger/status/1373747841944883201

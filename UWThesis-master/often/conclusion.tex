\section{Conclusion}
\label{sec:pi-concl}

The \toolnamec plugin addresses the main limitations of the \sysname prototype:
\sysname had limited support for patch application,
supported a narrow class of changes,
did not support typical proof engineering workflows like tactics,
and only retroactively \textit{could have} helped proof engineers in a few practical use cases.
\toolnamec, in contrast, supports patch application in a principled manner,
broadens the scope of \sysnamelong to include a large and flexible class of changes,
is built with workflow integration including tactics in mind,
and can save and in fact already has saved work for proof engineers in practical use cases.

At this point, it is fair to say that my \kl{thesis} holds:

\begin{quote}
Changes in programs, specifications, and proofs can carry information that a tool can extract, generalize, and apply to fix other proofs broken by the same change (Sections~\ref{sec:pumpkin-approach},~\ref{sec:pumpkin-diff},~\ref{sec:pumpkin-trans},~\ref{sec:pi-approach},~\ref{sec:pi-diff},and~\ref{sec:pi-trans}). A tool that automates this (Sections~\ref{sec:pumpkin-impl} and~\ref{sec:pi-implementation}) can save work for proof engineers relative to reference manual repairs in 
practical use cases (Sections~\ref{sec:pumpkin-results} and~\ref{sec:pi-results}).
\end{quote}
And so there really is \kl{reason to believe}.

I will talk about what that means for proof engineers---and what I believe the next era of verification can look like---in Chapter~\ref{chapt:conclusions}.
But first, I will back up a bit and talk about related work.

\subsection{The Workflow}
\label{sec:mot-workflow}

% TODO move this back to pattern matching!!! since eliminator stuff will come later
For a moment, let us assume some primitives from the Coq standard library: the type \lstinline{nat} of natural numbers,
the type \lstinline{list} of polymorphic lists, and the \lstinline{length} function that computes the length of a list as a natural number.
We start by writing the list \lstinline{zip} program, then specify what it means to preserve its length, and then finally
write an interactive proof that shows that specification actually holds.
Coq checks this proof and lets us now that our proof is correct, so our \lstinline{zip} function is verified.

\begin{figure}
\begin{lstlisting}
zip {T$_1$} {T$_2$} (l$_1$ : list T$_1$) (l$_2$ : list T$_2$) : list (T$_1$ * T$_2$) :=
  match l$_1$, l$_2$ with
  | nil, _ => nil
  | _, nil => nil
  | cons t$_1$ tl$_1$, cons t$_2$ tl$_2$ => cons (t$_1$, t$_2$) (zip tl$_1$ tl$_2$)
  end.
\end{lstlisting}
\caption{The list \lstinline{zip} function, taken from an existing tool~\cite{TODO}.} % TODO hs-to-coq cite
\label{fig:zip}
\end{figure}

\paragraph{Program} The list \lstinline{zip} function is in Figure~\ref{fig:zip}.
It takes as arguments two lists \lstinline{l}$_1$ and \lstinline{l}$_2$ of possibly different types \lstinline{T}$_1$ and \lstinline{T}$_2$, and zips them together into
a list of pairs \lstinline{(T}$_1$\lstinline{ * T}$_2$\lstinline{)}.
For example, if the input lists are: % TODO put this in a figure tbh, like from the slides

\begin{lstlisting}
(* [1; 2; 3; 4] *)
l$_1$ := cons 1 (cons 2 (cons 3 (cons 4 nil))).

(* ["x"; "y"; "z"] *)
l$_2$ := cons "x" (cons "y" (cons "z" nil)).
\end{lstlisting}
then \lstinline{zip} applied to those two lists returns:

\begin{lstlisting}
(* [(1, "x"); (2, "y"); (3, "z")] *)
cons (1, "x") (cons (2, "y") (cons (3, "z") nil)).
\end{lstlisting}
It is worth noting that the implementation of \lstinline{zip} has to make some decision with
what to do with the extra \lstinline{4} at the end---that is, how \lstinline{zip} behaves when the input
lists are different lengths.
The decision that this implementation makes is to just ignore those extra elements.

Otherwise, the implementation is fairly standard.
If \lstinline{l}$_1$ is \lstinline{nil} (first case),
or if \lstinline{l}$_2$ is \lstinline{nil} (second case), 
then \lstinline{zip} returns \lstinline{nil}.
Otherwise,
\lstinline{zip} combines the first two elements of each list into a pair (\lstinline{(t}$_1$\lstinline{, t}$_2$\lstinline{)}),
then sticks that in front of (using \lstinline{cons}) the result of recursively calling \lstinline{zip} on the tails of each list
(\lstinline{zip} \lstinline{tl}$_1$ \lstinline{tl}$_2$). % TODO a bit hard to understand probably, may need more explanation

\begin{figure}
\begin{minipage}{0.49\textwidth}
\begin{lstlisting}
Theorem zip_preserves_length :
  $\forall$ {T$_1$} {T$_2$} (l$_1$ : list T$_1$) (l$_2$ : list T$_2$),
    length l$_1$ = length l$_2$ $\rightarrow$
    length (zip l$_1$ l$_2$) = length l$_1$.
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.49\textwidth}
\begin{lstlisting}
Theorem zip_preserves_length :
  $\forall$ {T$_1$} {T$_2$} (l$_1$ : list T$_1$) (l$_2$ : list T$_2$),
    length (zip l$_1$ l$_2$) = min (length l$_1$) (length l$_2$).
\end{lstlisting}
\end{minipage}
\caption{Two possible specifications of a proof that \lstinline{zip} preserves the length of the input lists.}
\label{fig:zip-pres}
\end{figure}

\paragraph{Specification} Once we have written our \lstinline{zip} function, we can then specify what we 
want to prove about it: that the \lstinline{zip} function preserves the lengths of the inputs \lstinline{l}$_1$ and \lstinline{l}$_2$.
We do this by defining a type \lstinline{zip_preserves_length} (Figure~\ref{fig:zip-pres}, left), which in Coq we state as a \lstinline{Theorem}.
This theorem takes advantage of \kl{Gallina}'s rich type system to quantify over all possible input lists \lstinline{l}$_1$ and \lstinline{l}$_2$.
It says that if the lengths of the inputs are the same, then the length of the output is the same as the lengths of the inputs.
Our proof will soon show that this type is inhabited, and so this statement is true.

It is worth noting that this step of choosing a specification is a bit of an art---we have some freedom when we choose our specification.
We could just as well have chosen a different version of \lstinline{zip_preserves_length} (Figure~\ref{fig:zip-pres}, right)
that states that the length of the output is the \textit{minimum} of the lengths of the inputs (using \lstinline{min} from the Coq standard library).
This is also true for our \lstinline{zip} implementation, and in fact it is stronger---it implies the original theorem as well.
But regardless of which version we choose, we then get to the fun part of actually writing our proof.

\paragraph{Proof} As I mentioned earlier, it is possible to write proofs directly in \kl{Gallina}---but this can be difficult.
Instead, it is more common to write proofs interactively using the tactic language \kl{Ltac}.
Each tactic in \kl{Ltac} is effectively a search procedure for a proof term, given the context and goals at each step of the proof.
The way that this works is, after we state the theorem that we want to prove:

\begin{lstlisting}
Theorem zip_preserves_length :
  $\forall$ {T$_1$} {T$_2$} (l$_1$ : list T$_1$) (l$_2$ : list T$_2$),
    length l$_1$ = length l$_2$ $\rightarrow$
    length (zip l$_1$ l$_2$) = length l$_1$.
\end{lstlisting}
we then add one more word:

\begin{lstlisting}
Proof.
\end{lstlisting}
then step down past that word inside of an IDE. % TODO expand acronym? or something?
The IDE then drops into an interactive proof mode.
In that proof mode, it tracks the context of the proof so far, along with the goal we want to prove.
After each tactic we type and step past, Coq responds by refining the goal into some subgoal
and updating the context.
We continue this until no goals remain.
The survey paper~\cite{PGL-045} has a good overview of the tactic language in Coq and in other proof assistants,
plus different interfaces and IDEs for writing proofs interactively and screenshots of them in action.

In this case, after stepping past \lstinline{Proof} in our IDE, 
our initial context (above the line) is empty, and our initial goal (below the line) is the original theorem:

\begin{lstlisting}
______________________________________(1/1)
$\forall$ {T$_1$} {T$_2$} (l$_1$ : list T$_1$) (l$_2$ : list T$_2$),
  length l$_1$ = length l$_2$ $\rightarrow$
  length (zip l$_1$ l$_2$) = length l$_1$.
\end{lstlisting}
We can start this proof with the introduction tactic \lstinline{intros}:

\begin{lstlisting}
  intros T$_1$ T$_2$ l$_1$.
\end{lstlisting}
This is essentially the equivalent of the natural language proof strategy ``assume arbitrary \lstinline{T}$_1$, \lstinline{T}$_2$, and \lstinline{l}$_1$.''
That is, it moves the universally quantified arguments from our goal into our context:

\begin{lstlisting}
T$_1$ : Type
T$_2$ : Type
l$_1$ : list T$_1$
______________________________________(1/1)
$\forall$ (l$_2$ : list T$_2$),
  length l$_1$ = length l$_2$ $\rightarrow$
  length (zip l$_1$ l$_2$) = length l$_1$.
\end{lstlisting}
From this state, we can induct over the input list (choosing names for variables Coq introduces in the inductive case):

\begin{lstlisting}
  induction l$_1$ as [|t$_1$ tl$_1$ IHtl$_1$].
\end{lstlisting}
This breaks into two subgoals and subcontexts: one for the base case and one for the inductive case.
The base case:
\begin{lstlisting}
T$_1$ : Type
T$_2$ : Type
______________________________________(1/2)
$\forall$ l$_2$ : list T$_2$,
  length nil = length l$_3$ $\rightarrow$
  length (zip nil l$_2$) = length nil.
\end{lstlisting}
holds by reflexivity, which the \lstinline{auto} tactic takes care of.

In the inductive case:

\begin{lstlisting}
T$_1$ : Type
T$_2$ : Type
t$_1$ : T$_1$
tl$_1$ : list T$_1$
IHtl$_1$ : $\forall$ l$_2$ : list T$_2$,
        length tl$_1$ = length l$_2$ $\rightarrow$
        length (zip tl$_1$ l$_2$) = length tl$_1$
______________________________________(2/2)
$\forall$ l$_2$ : list T2,
  length (cons t$_1$ tl$_1$) = length l$_2$ $\rightarrow$
  length (zip (cons t$_1$ tl$_1$) l$_2$) = length (cons t$_1$ tl$_1$).
\end{lstlisting}
we again use \lstinline{intros} and \lstinline{induction}, this time to induct over \lstinline{l}$_2$.
This again produces two subgoals: one for the base case and one for the inductive case.
The base case has an absurd hypothesis, which we introduce as \lstinline{H} and then use \lstinline{auto} to show our conclusion holds:
The inductive case holds by simplification and rewriting by the inductive hypothesis \lstinline{IHtl}$_1$. % TODO show

After this, no goals remain, so our proof is done; we can write \lstinline{Defined}.
What happens when we write \lstinline{Defined} is that Coq compiles that proof script down to a proof term.
It then checks the type of that term and ensures that it is exactly the theorem we have stated.
Since it is, Coq lets us know that our proof is correct, so our \lstinline{zip} function is verified.

\begin{figure}
\begin{lstlisting}
Theorem zip_preserves_length :
  $\forall$ {T$_1$} {T$_2$} (l$_1$ : list T$_1$) (l$_2$ : list T$_2$),
    length l$_1$ = length l$_2$ $\rightarrow$
    length (zip l$_1$ l$_2$) = length l$_1$.
Proof.
  intros T1 T2 l1. (@\codesimb{induction l$_1$}@) as [|t$_1$ tl$_1$ IHtl$_1$].
  - (@\codesima{auto.}@)
  - intros l2. (@\codesimc{induction l2}@) as [|t$_2$ tl$_2$ IHtl$_2$].
    + (@\codesimd{intros H. auto.}@)
    + (@\codesime{intros H. simpl. rewrite IHtl$_1$; auto.}@)
Defined.
\end{lstlisting}
\begin{lstlisting}
zip_preserves_length :
  $\forall$ {T$_1$} {T$_2$} (l$_1$ : list T$_1$) (l$_2$ : list T$_2$),
    length l$_1$ = length l$_2$ $\rightarrow$
    length (zip l$_1$ l$_2$) = length l$_1$
:=
fun (T$_1$ T$_2$ : Type) (l$_1$ : list T$_1$) (l$_2$ : list T$_2$) =>
  (@\codesimb{list\_rect}@) (fun (l$_1$ : list T$_1$) => $\ldots$)
    (@\codesima{(fun (l$_2$ : list T$_2$) \_ => eq\_refl)}@)
    (fun (t$_1$ : T$_1$) (tl$_1$ : list T$_1$) (IHtl$_1$ : $\ldots$) (l$_2$ : list T$_2$) =>
      (@\codesimc{list\_rect}@) (fun (l$_2$ : list T$_2$) => $\ldots$)
        (@\codesimd{(fun (H : $\ldots$) => eq\_sym H)}@)
        (fun (t$_2$ : T$_2$) (tl$_2$ : list T$_2$) (IHtl$_2$ : $\ldots$) =>
          (@\codesime{fun (H : $\ldots$) => eq\_ind\_r $\ldots$ eq\_refl (IHtl$_1$ $\ldots$)}@))
        (@\codesimc{l$_2$}@))
  (@\codesimb{l$_1$}@)
  l$_2$.
\end{lstlisting}
\caption{A proof script (top) and corresponding proof term (bottom) in Coq that shows that the list zip function preserves its length.
Some details of the proof term are omitted for simplicity.
Corresponding parts of the proof are highlighted in the same color and annotated with the same number; the rest is boilerplate.}
\label{fig:zip-proof}
\end{figure}

Figure~\ref{fig:zip-proof} shows the resulting proof script for this theorem (top), along with the corresponding proof term (bottom).
As we can see, the proof term is quite complicated---I will explain what it means soon, in Section~\ref{sec:mot-theory}.
The important thing to note for now is that  the details of this low-leve proof term do not matter to us,
since we can write the high-level proof script on the top instead.
Even though this proof script is still a bit manual for the sake of demonstration,
it is much simpler than the low-level proof term.

Still, there is a correspondence between the proof script and the proof term, highlighted in the same color in Figure~\ref{fig:zip-proof}.
For example, every call to \lstinline{induction} in the proof script shows up as an application of a function \lstinline{list_rect},
which is the induction principle for \lstinline{list}.
In Section~\ref{TODO}, I will explain this connection in more detail by introducing a prototype decompiler from proof terms back up to proof scripts.
This decompiler makes it possible for \sysname to work over highly structured \kl{Gallina} terms,
but produce proof scripts that the proof engineer can use going forward.

Writing proofs using tactics does indeed proof development easier than writing raw proof terms.
But these highly structured proof terms carry a lot of information that is lost at the level of tactics.
It is exactly that rich structure---the type theory beneath \kl{Gallina}---that makes a principled approach to proof repair possible.






\section{Approach}
\label{sec:pumpkin-approach}

In the example from Section~\ref{sec:patch-motivating}, the change in \lstinline{IZR} broke many proofs.
The example patch to a single proof (the proof of \lstinline{plus_negative_positive}) carried enough information (the rewrite by \lstinline{INR_IPR})
to fix the other broken proofs.
More generally, example-based proof repair takes advantage of the fact that an example patch to a broken proof can carry enough information to fix other proofs
broken by the same change.

\sysname implements a prototype of this.
To use \sysname (Section~\ref{sec:pumpkin-workflow}), the proof engineer modifies a single proof script to provide an \textit{example} of how to adapt a proof to a change.
\sysname extracts that information into a \textit{patch candidate}---a function that describes the change in the example patched proof,
but that is localized to the context of the example, and not yet enough to fix other proofs broken by the change.
\sysname then generalizes that candidate into a \textit{reusable patch}: a function
that can be used to fix other broken proofs broken by the same change, which \sysname defines as a Coq term.
In other words, looking back to the thesis statement, the information shows up in the difference between versions of the example patched proof.
\sysname can extract, generalize, and in some cases apply that information.

The \sysname prototype focuses on finding reusable patches to proofs in response to certain changes in the content of programs and specifications (Section~\ref{sec:pumpkin-scope}).
It does this using a combination of semantic differencing and proof term transformations:
Differencing (Section~\ref{sec:pumpkin-spec-diff} looks at the difference between versions of the example patched proof for this information, and finds the candidate.
Then, proof term transformations (Section~\ref{pumpkin-spec-trans}) modify that candidate to produce the reusable proof patch.
All of this happens over proof terms in Gallina, since tactics may hide necessary information as I will soon show.
\sysname has only preliminary support for proof script integration and patch application (see Section~\ref{sec:pumpkin-impl}),
though I will address this limitation with the \toolnamec extension in Chapter~\ref{chapt:pi}.

\subsection{Workflow: Repair by Example}
\label{sec:pumpkin-workflow}

The interface to \sysname is exposed to the proof engineer as a \textit{command}. % TODO use knowledge package, and maybe move back to Chapter 2
Commands in Coq are similar to tactics, except that they can occur outside of the context of proofs, and define new terms.
In this case, \sysname extends Coq with a new command called \lstinline{Patch Proof}, with the syntax:

\begin{lstlisting}
  Patch Proof old_proof new_proof as patch_name. 
\end{lstlisting}
where \lstinline{old_proof} and \lstinline{new_proof} are the old and new versions of the example patched proof,
and \lstinline{patch_name} is the desired name of the reusable proof patch.\footnote{Section~\ref{sec:pumpkin-impl} describes an alternative interface for \sysname with Git integration.}
This invokes the \sysname plugin, which searches for a reusable proof patch
and defines it as a new term if successful.
All terms that \sysname defines are type checked in the end, so \sysname does not extend the TCB. % TODO use the cool knowledge package here, since introduced a while ago 

\begin{figure}
%\begin{algorithm}
\begin{algorithmic}
\renewcommand{\thealgorithm}{}
\footnotesize
\caption{\footnotesize{find\_patch(old\_proof, new\_proof)}}
    \STATE \diff{\textit{diff} types of old\_proof and new\_proof for goals}
    \STATE \diff{\textit{diff} terms old\_proof and new\_proof for candidates}
    \IF{there are candidates}
      \STATE \diff{\textit{transform} candidates}
      \IFRETURN{there are patches}{patches}
    \ENDIF
    \RETURN failure
\end{algorithmic}
%\end{algorithm}
\caption{Search procedure for a reusable proof patch in \sysname.}
\label{alg:patching}	
\end{figure}

When the proof engineer calls \lstinline{Patch Proof}, this invokes the proof patch search procedure in Figure~\ref{alg:patching}.
The search procedure starts by differencing the \textit{types} of \lstinline{old_proof} and \lstinline{new_proof}
(that is, the theorems they prove).
The result that it finds is the \textit{goal type}: the type that the reusable proof patch should have.
It then differences the \textit{terms} \lstinline{old_proof} and \lstinline{new_proof} directly to identify candidate proof patches,
which are themselves proof terms.
Finally, it transforms those proof patches directly into a reusable patch.
If it finds a patch with the goal type, it succeeds and defines it.

\begin{figure*}
\begin{minipage}{0.50\textwidth}
\lstset{language=coq, aboveskip=0pt, belowskip=0pt}
\lstinputlisting[firstline=1, lastline=1]{repair/introex.tex}
\lstinputlisting[backgroundcolor=\color{orange!35},firstline=2,lastline=2]{repair/introex.tex}
\lstinputlisting[firstline=3, lastline=8]{repair/introex.tex}
\lstinputlisting[firstline=1, lastline=4]{repair/introexterm.tex}
\lstinputlisting[backgroundcolor=\color{orange!35},firstline=5,lastline=5]{repair/introexterm.tex}
\lstinputlisting[firstline=6, lastline=9]{repair/introexterm.tex}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
\lstset{language=coq, aboveskip=0pt, belowskip=0pt}
\lstinputlisting[firstline=9, lastline=9]{repair/introex.tex}
\lstinputlisting[backgroundcolor=\color{orange!35},firstline=10,lastline=10]{repair/introex.tex}
\lstinputlisting[firstline=11, lastline=16]{repair/introex.tex}
\lstinputlisting[firstline=11, lastline=14]{repair/introexterm.tex}
\lstinputlisting[backgroundcolor=\color{orange!35},firstline=15,lastline=15]{repair/introexterm.tex}
\lstinputlisting[firstline=16, lastline=19]{repair/introexterm.tex}
\end{minipage}
\caption{Two proofs with different conclusions (top) and the
corresponding proof terms (bottom) with relevant type information. We highlight the change in theorem conclusion and
the difference in terms that corresponds to a patch.}
\label{fig:example}
\end{figure*}

Consider, for example, the change from the theorem \lstinline{old} to the slightly stronger theorem \lstinline{new} in Figure~\ref{fig:example}.
Changing \lstinline{old} to \lstinline{new} can break proofs that used to successfully apply \lstinline{old}, so that a proof like this:

\begin{lstlisting}[language=coq]
Proof.
  $\ldots$
  (@\succeeds{apply old.}@)(@\vspace{-0.1cm}@)
  $\ldots$
Defined.
\end{lstlisting}
fails after migrating to \lstinline{new}:

\begin{lstlisting}[language=coq]
Proof.
  $\ldots$
  (@\fails{apply new.}@)(@\vspace{-0.1cm}@)
  $\ldots$
Defined.
\end{lstlisting}
When we call:

\begin{lstlisting}
Patch Proof old new as patch.
\end{lstlisting}
\sysname invokes the search procedure, which differences \lstinline{old} and \lstinline{new} to infer the goal type for the patch.
In this case, it infers the following goal:

\begin{lstlisting}[language=coq]
  (@\ltacforall@) n m p, n <= m $\rightarrow$ m <= p $\rightarrow$ (@\diff{n <= p}@) $\rightarrow$ (@\diff{n <= p + 1}@)
\end{lstlisting}
which takes us from the conclusion of \lstinline{new} back to the conclusion of \lstinline{old}.
It then differences the terms \lstinline{old} and \lstinline{new} to identify candidate proof patches (Section~\ref{sec:pumpkin-spec-diff}),
then tranforms those candidates to a reusable proof patch with that type (Section~\ref{sec:pumpkin-spec-trans}),
which it defines as a new constant \lstinline{patch}.
This is something that we can use to fix other proofs broken by this change, either by applying it with traditional proof automation:

\begin{lstlisting}[language=coq]
Proof.
  $\ldots$
  (@\diff{apply patch.}@) (@\succeeds{apply new.}@)
  $\ldots$
Defined.
\end{lstlisting}
or by using the automation in Section~\ref{sec:pumpkin-impl}.

\subsection{Scope: Changes in Content}
\label{sec:pumpkin-scope}

The search procedure in Figure~\ref{alg:patching} searches for patches to proofs broken by changes in the \textit{content} of programs and specifications.
For example, \sysname can support the change in Figure~\ref{fig:example}, since content (the conclusion of the theorem) changes,
but all else remains identical.
In general, the \sysname prototype does not support any changes that add, remove, or rearrange any hypotheses.
Chapter~\ref{chapt:pi} introduces an extension to \sysname that supports a broad class of
changes in datatypes that may change in those ways.

The search procedure can be configured to different classes of change in the content of programs and specifications.
Thus, before running the search procedure, \sysname infers a \textit{configuration} from the example change.
This configuration customizes the highlighted lines for an entire class of changes:
it determines what to diff on lines 1 and 2,
and what transformations to run to achieve what goal on line 4.

Figure~\ref{fig:example} used the configuration for a change in the conclusion of a theorem.
Section~\ref{sec:pumpkin-results} describes real-world examples that demonstrate more configurations.
In total, the \sysname prototype currently implements six configurations, corresponding to changes in:

\begin{enumerate}
\item conclusions of theorems,
\item hypotheses of theorems,
\item dependent arguments to constructors of inductive types, 
\item conclusions of constructors of inductive types,
\item cases of fixpoints, and
\item nothing.\footnote{This change, while trivial, can be used to optimize proofs! See Section~\ref{sec:pumpkin-impl}.}
\end{enumerate}
The support for these changes is limited in expressiveness in power;
more information on limitations in scope can be found in the repository. % TODO link

\subsection{Differencing: Candidates from Examples}
\label{sec:pumpkin-spec-diff}

Differencing takes as inputs $\ldots$ and returns $\ldots$:

\begin{itemize}
\item \textbf{Inputs}: $\ldots$, assuming:
\begin{itemize}
\item $\ldots$
\end{itemize}
\item \textbf{Outputs}: $\ldots$, guaranteeing:
\begin{itemize}
\item $\ldots$
\end{itemize}
\end{itemize}

other details like what is proven or whatever (here, maybe the list of differencing procedures actually supported?)

\iffalse
\paragraph{Input: Example Patched Proof}
They look at the difference between the old and new versions of a single example patched proof in response to that change.
Old and new version of example patched proof.
%\sysname is a proof-of-concept and does not yet handle some kinds of proofs.
%In each scenario, we made minor modifications to proofs so that we could use \sysname (for example,
%using induction instead of destruction).

\paragraph{Output: Patch Candidates}
Functions that map back and forth between the old and new versions
of the example patch proof in a particular context, but do not yet generalize to other contexts.
\fi

\subsection{Transformations: Patches from Candidates}
\label{sec:pumpkin-spec-trans}


% New (outline for now), plus parts of PUMPKIN PATCH Motivating the Core



To motivate this workflow, consider using \sysname to search the proofs in
Figure~\ref{fig:example} for a patch between conclusions.
Except we will show a place where the lemma is actually applied.
Note that the tactics don't change even though the terms do---and even though the change could break other proofs.

So what do we do?
We invoke the plugin using \lstinline{old} and \lstinline{new} as the example change:

\begin{lstlisting}[language=ml4]
  Patch Proof old new as patch.
\end{lstlisting}

The first thing that \sysname does is determine the configuration.
Here, it uses the configuration for changes in conclusions of two proofs
that induct over the same hypothesis. Given two such
proofs:

%We describe one
%such procedure in this section; we descibe three more
%in Section~\ref{sec:case}.
\begin{lstlisting}[language=coq]
  (@\ltacforall@) x, H x $\rightarrow$ (@\diff{P}@) x(@\vspace{-0.1cm}@)
  (@\ltacforall@) x, H x $\rightarrow$ (@\diff{P'}@) x
\end{lstlisting}
\sysname searches for a patch with this type:

\begin{lstlisting}[language=coq]
  (@\ltacforall@) x, H x $\rightarrow$ (@\diff{P'}@) x $\rightarrow$ (@\diff{P}@) x
\end{lstlisting}
using this configuration:

\begin{algorithm}
\footnotesize
\begin{algorithmic}[1]
%  Is it really necessary to say that an algorithm might do initialization?
%  \STATE Build trees for search
  %\STATE build trees for proofs
  %\REPEAT
    \STATE \textit{diff} conclusion types for goals
    \STATE \textit{diff} conclusion terms for candidates
    \STATE \textbf{if} there are candidates \textbf{then}
    \STATE \hspace*{1em} \textit{abstract} and then \textit{specialize} candidates
\end{algorithmic}
\end{algorithm}

When it runs the procedure,
\sysname first determines the type that a patch from \lstinline{new} to \lstinline{old} should have.
To determine this, it semantically \textit{diffs} the types and finds this goal type:

\begin{lstlisting}[language=coq]
  (@\ltacforall@) n m p, n <= m $\rightarrow$ m <= p $\rightarrow$ (@\diff{n <= p}@) $\rightarrow$ (@\diff{n <= p + 1}@)
\end{lstlisting}
It then breaks each inductive proof into cases and determines an intermediate goal type for the candidate.
%recursively searches each case for a candidate.
In the base case, for example, it \textit{diffs} the types and determines that a candidate
between the base cases of \lstinline{new} and \lstinline{old} should have this type (lines 11 and 12):

\begin{lstlisting}
  (@\diff{(fun p0 => n <= p0)}@) m $\rightarrow$ (@\diff{(fun p0 => n <= p0 + 1)}@) m
\end{lstlisting}
It then \textit{diffs} the terms (line 13) for such a candidate:

\begin{lstlisting}
  fun n m p H0 H1 =>(@\vspace{-0.04cm}@)
    (fun (H : n <= m) => (@\diff{le\_plus\_trans n m 1}@) H)(@\vspace{-0.04cm}@)
  : (@\ltacforall@) n m p, n <= m -> m <= p -> (@\diff{n <= m}@) -> (@\diff{n <= m + 1}@)
\end{lstlisting}

This candidate is close, but it is not yet a patch. This candidate
maps base case to base case (it is applied to \lstinline{m}); the patch should map conclusion to conclusion (it should
be applied to \lstinline{p}).

Here, \sysname \textit{abstracts} this candidate by \lstinline{m} (line 11), which lifts it out of the base case:

\begin{lstlisting}
  fun (@\diff{n0}@) n m p H0 H1 =>(@\vspace{-0.04cm}@)
    (fun (H : n <= (@\diff{n0}@)) => le_plus_trans n (@\diff{n0}@) 1 H)(@\vspace{-0.04cm}@)
  : (@\ltacforall@) (@\diff{n0}@) n m p, n <= m -> m <= p -> n <= (@\diff{n0}@) -> n <= (@\diff{n0}@) + 1
\end{lstlisting}
\sysname then \textit{specializes} this candidate to \lstinline{p} (line 16), the argument
to the conclusion of \lstinline{le_ind}. This produces a patch:

\begin{lstlisting}
  patch n m p H0 H1 := (@\vspace{-0.04cm}@)
    (fun (H : n <= (@\diff{p}@)) => le_plus_trans n (@\diff{p}@) 1 H)(@\vspace{-0.04cm}@)
  : (@\ltacforall@) n m p, n <= m $\rightarrow$ m <= p $\rightarrow$ n <= (@\diff{p}@) -> n <= (@\diff{p}@) + 1
\end{lstlisting}
The user can then use \lstinline{patch} to fix other broken proofs.
For example, given a proof that applies \lstinline{old}, the user can use \lstinline{patch} to prove the same conclusion
by applying \lstinline{new}:

\begin{lstlisting}[language=coq]
  (@\succeeds{apply old.}@)(@\vspace{-0.1cm}@)
  (@\diff{apply patch.}@) (@\succeeds{apply new.}@)
\end{lstlisting}
This can happen automatically through hint databases.

This simple example uses only two transformations. The other transformations help turn candidates
into patches in similar ways. We discuss all of this in detail later.
Later we will see real-world examples that demonstrate more configurations, too.
For now let's talk about the scope more.

Mentioned earlier there's a configuration for the procedure.
There are four transformations that turn patch candidates into reusable proof patches:

\begin{enumerate}
\item \textit{Patch specialization} to arguments
\item \textit{Patch abstraction} of arguments or functions
\item \textit{Patch inversion} to reverse a patch
\item \textit{Lemma factoring} to break a term into parts
\end{enumerate}
The configuration chooses among these strategically based on the structure of the proof term.

The transformations takes as inputs $\ldots$ and return $\ldots$:

\begin{itemize}
\item \textbf{Inputs}: $\ldots$, assuming:
\begin{itemize}
\item $\ldots$
\end{itemize}
\item \textbf{Outputs}: $\ldots$, guaranteeing:
\begin{itemize}
\item $\ldots$
\end{itemize}
\end{itemize}

other details like what is proven or whatever

\iffalse
\paragraph{Input: Patch Candidates}
They come from differencing.

\paragraph{Output: Reusable Proof Patch}
The corresponding proof term transformations then try to transform each of those candidate patch functions to a more general \textit{reusable proof patch}:
a function that can be applied with traditional proof automation to fix other proofs broken by the same change.
\fi


\section{The Coq Proof Assistant}
\label{sec:mot-coq}

This thesis focuses on proof developments done in Coq.
I already briefly introduced the Coq workflow in the introduction.
Here I am going to go into a bit more detail and talk about foundations as relevant to this thesis.
I am not going to teach you all of Coq in this thesis;
good sources for learning Coq from scratch include the books Certified Programming with Dependent Types~\cite{chlipala:cpdt}
and Software Foundations~\cite{software-foundations}.

Workflow from intro, but with specific languages named (Ltac, Gallina); refer to a diagram

What tactics really are, and what compiling them means

Gallina and its foundations

CoC

\begin{figure}
   \lstinputlisting[firstline=1, lastline=3]{often/listswap.tex}
\caption{The \lstinline{list} datatype in Coq, from the Coq standard library.}
\label{fig:list}
\end{figure}

Inductive types, theory (CIC) and practice (Gallina); constructors and eliminators.
For example, a \lstinline{list} in Coq (Figure~\ref{fig:list}) is an inductive datatype that is 
either empty (the \lstinline{nil} constructor), or the result
of placing an element in front of another \lstinline{list} (the \lstinline{cons} constructor).
Mention the induction principle for \lstinline{list}.

\begin{figure}
\begin{lstlisting}
Definition length (T : Type) : list T $\rightarrow$ nat := fix length l :=
  match l with
   | nil => O
   | _ :: l' => S (length l')
  end.
\end{lstlisting}
\caption{The \lstinline{length} function for \lstinline{list} in Coq, from the Coq standard library.}
\label{fig:length}
\end{figure}

Once we have inductive types, we can write functions and proofs about them, like the \lstinline{length} function (Figure~\ref{fig:length}).
The \lstinline{length} of the empty list \lstinline{nil} is \lstinline{0}, and the length of any other list
is just the successor (\lstinline{S}) of the result of recursively calling \lstinline{length} on everything but the first element of the list.
Note we can also write this using eliminators (show), and in fact that reduces to pattern matching.
When we reason about theory we think about eliminators.

Conventions in this thesis, including using induction principles/eliminators instead of pattern matching, and assuming primitive.
Infinite universe hierarchy---mostly can ignore in this thesis, though matters in implementation.

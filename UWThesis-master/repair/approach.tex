\section{Approach}
\label{sec:pumpkin-approach}

In the example from Section~\ref{sec:patch-motivating}, the change in \lstinline{IZR} broke many proofs.
The example patch to a single proof (the proof of \lstinline{plus_negative_positive}) carried enough information (the rewrite by \lstinline{INR_IPR})
to fix the other broken proofs.
More generally, example-based proof repair takes advantage of the fact that an example patch to a broken proof can carry enough information to fix other proofs
broken by the same change.

\sysname implements a prototype of this.
To use \sysname (Section~\ref{sec:pumpkin-workflow}), the proof engineer modifies a single proof script to provide an \textit{example} of how to adapt a proof to a change.
\sysname extracts that information into a \textit{patch candidate}---a function that describes the change in the example patched proof,
but that is localized to the context of the example, and not yet enough to fix other proofs broken by the change.
\sysname then generalizes that candidate into a \textit{reusable patch}: a function
that can be used to fix other broken proofs broken by the same change, which \sysname defines as a Coq term.
In other words, looking back to the thesis statement, the information shows up in the difference between versions of the example patched proof.
\sysname can extract, generalize, and in some cases apply that information.

The \sysname prototype focuses on finding reusable patches to proofs in response to certain changes in the content of programs and specifications (Section~\ref{sec:pumpkin-scope}).
It does this using a combination of semantic differencing and proof term transformations:
Differencing (Section~\ref{sec:pumpkin-spec-diff} looks at the difference between versions of the example patched proof for this information, and finds the candidate.
Then, proof term transformations (Section~\ref{pumpkin-spec-trans}) modify that candidate to produce the reusable proof patch.
All of this happens over proof terms in Gallina, since tactics may hide necessary information as I will soon show.
\sysname has only preliminary support for proof script integration and patch application (see Section~\ref{sec:pumpkin-impl}),
though I will address this limitation with the \toolnamec extension in Chapter~\ref{chapt:pi}.

\subsection{Workflow: Patching by Example}
\label{sec:pumpkin-workflow}

The interface to \sysname is exposed to the proof engineer as a command.
Commands in Coq are similar to tactics, except that they can occur outside of the context of proofs, and define new terms.
In this case, \sysname extends Coq with a new command called \lstinline{Patch Proof}, with the syntax:

\begin{lstlisting}
  Patch Proof old_proof new_proof as patch_name. 
\end{lstlisting}
where \lstinline{old_proof} and \lstinline{new_proof} are the old and new versions of the example patched proof,
and \lstinline{patch_name} is the desired name of the reusable proof patch.\footnote{Section~\ref{sec:pumpkin-impl} describes an alternative interface for \sysname with Git integration.}
This invokes the \sysname plugin, which searches for a reusable proof patch
and defines it as a new term if successful.
All terms that \sysname defines are type checked in the end, so \sysname does not extend the TCB. % TODO use the cool knowledge package here, since introduced a while ago 

\begin{figure}
%\begin{algorithm}
\begin{algorithmic}
\renewcommand{\thealgorithm}{}
\footnotesize
\caption{\footnotesize{find\_patch(old\_proof, new\_proof)}}
    \STATE \diff{\textit{diff} types of old\_proof and new\_proof for goals}
    \STATE \diff{\textit{diff} terms old\_proof and new\_proof for candidates}
    \IF{there are candidates}
      \STATE \diff{\textit{factor}, \textit{abstract}, \textit{specialize}, and/or \textit{invert} candidates}
      \IFRETURN{there are patches}{patches}
    \ENDIF
    \RETURN failure
\end{algorithmic}
%\end{algorithm}
\caption{Search procedure for a reusable proof patch in \sysname.}
\label{alg:patching}	
\end{figure}

When the proof engineer calls \lstinline{Patch Proof}, this invokes the proof patch search procedure in Figure~\ref{alg:patching}.
\lstinline{Patch Proof} takes as input the old and new version of an example proof patched in response to some breaking change.
When succesful, it returns the reusable proof patch as a function, and defines it in Coq.
The \sysname repository contains a more detailed user guide.

% New (outline for now), plus parts of PUMPKIN PATCH Motivating the Core

\begin{figure*}
\begin{minipage}{0.50\textwidth}
\lstset{language=coq, aboveskip=0pt, belowskip=0pt}
\lstinputlisting[firstline=1, lastline=1]{repair/introex.tex}
\lstinputlisting[backgroundcolor=\color{orange!35},firstline=2,lastline=2]{repair/introex.tex}
\lstinputlisting[firstline=3, lastline=8]{repair/introex.tex}
\lstinputlisting[firstline=1, lastline=4]{repair/introexterm.tex}
\lstinputlisting[backgroundcolor=\color{orange!35},firstline=5,lastline=5]{repair/introexterm.tex}
\lstinputlisting[firstline=6, lastline=9]{repair/introexterm.tex}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
\lstset{language=coq, aboveskip=0pt, belowskip=0pt}
\lstinputlisting[firstline=9, lastline=9]{repair/introex.tex}
\lstinputlisting[backgroundcolor=\color{orange!35},firstline=10,lastline=10]{repair/introex.tex}
\lstinputlisting[firstline=11, lastline=16]{repair/introex.tex}
\lstinputlisting[firstline=11, lastline=14]{repair/introexterm.tex}
\lstinputlisting[backgroundcolor=\color{orange!35},firstline=15,lastline=15]{repair/introexterm.tex}
\lstinputlisting[firstline=16, lastline=19]{repair/introexterm.tex}
\end{minipage}
\caption{Two proofs with different conclusions (top) and the
corresponding proof terms (bottom) with relevant type information. We highlight the change in theorem conclusion and
the difference in terms that corresponds to a patch.}
\label{fig:example}
\end{figure*}

To motivate this workflow, consider using \sysname to search the proofs in
Figure~\ref{fig:example} for a patch between conclusions.
Except we will show a place where the lemma is actually applied.
Note that the tactics don't change even though the terms do---and even though the change could break other proofs.

So what do we do?
We invoke the plugin using \lstinline{old} and \lstinline{new} as the example change:

\begin{lstlisting}[language=ml4]
  Patch Proof old new as patch.
\end{lstlisting}

The first thing that \sysname does is determine the configuration.
Here, it uses the configuration for changes in conclusions of two proofs
that induct over the same hypothesis. Given two such
proofs:

%We describe one
%such procedure in this section; we descibe three more
%in Section~\ref{sec:case}.
\begin{lstlisting}[language=coq]
  (@\ltacforall@) x, H x $\rightarrow$ (@\diff{P}@) x(@\vspace{-0.1cm}@)
  (@\ltacforall@) x, H x $\rightarrow$ (@\diff{P'}@) x
\end{lstlisting}
\sysname searches for a patch with this type:

\begin{lstlisting}[language=coq]
  (@\ltacforall@) x, H x $\rightarrow$ (@\diff{P'}@) x $\rightarrow$ (@\diff{P}@) x
\end{lstlisting}
using this configuration:

\begin{algorithm}
\footnotesize
\begin{algorithmic}[1]
%  Is it really necessary to say that an algorithm might do initialization?
%  \STATE Build trees for search
  %\STATE build trees for proofs
  %\REPEAT
    \STATE \textit{diff} conclusion types for goals
    \STATE \textit{diff} conclusion terms for candidates
    \STATE \textbf{if} there are candidates \textbf{then}
    \STATE \hspace*{1em} \textit{abstract} and then \textit{specialize} candidates
\end{algorithmic}
\end{algorithm}

When it runs the procedure,
\sysname first determines the type that a patch from \lstinline{new} to \lstinline{old} should have.
To determine this, it semantically \textit{diffs} the types and finds this goal type:

\begin{lstlisting}[language=coq]
  (@\ltacforall@) n m p, n <= m $\rightarrow$ m <= p $\rightarrow$ (@\diff{n <= p}@) $\rightarrow$ (@\diff{n <= p + 1}@)
\end{lstlisting}
It then breaks each inductive proof into cases and determines an intermediate goal type for the candidate.
%recursively searches each case for a candidate.
In the base case, for example, it \textit{diffs} the types and determines that a candidate
between the base cases of \lstinline{new} and \lstinline{old} should have this type (lines 11 and 12):

\begin{lstlisting}
  (@\diff{(fun p0 => n <= p0)}@) m $\rightarrow$ (@\diff{(fun p0 => n <= p0 + 1)}@) m
\end{lstlisting}
It then \textit{diffs} the terms (line 13) for such a candidate:

\begin{lstlisting}
  fun n m p H0 H1 =>(@\vspace{-0.04cm}@)
    (fun (H : n <= m) => (@\diff{le\_plus\_trans n m 1}@) H)(@\vspace{-0.04cm}@)
  : (@\ltacforall@) n m p, n <= m -> m <= p -> (@\diff{n <= m}@) -> (@\diff{n <= m + 1}@)
\end{lstlisting}

This candidate is close, but it is not yet a patch. This candidate
maps base case to base case (it is applied to \lstinline{m}); the patch should map conclusion to conclusion (it should
be applied to \lstinline{p}).

Here, \sysname \textit{abstracts} this candidate by \lstinline{m} (line 11), which lifts it out of the base case:

\begin{lstlisting}
  fun (@\diff{n0}@) n m p H0 H1 =>(@\vspace{-0.04cm}@)
    (fun (H : n <= (@\diff{n0}@)) => le_plus_trans n (@\diff{n0}@) 1 H)(@\vspace{-0.04cm}@)
  : (@\ltacforall@) (@\diff{n0}@) n m p, n <= m -> m <= p -> n <= (@\diff{n0}@) -> n <= (@\diff{n0}@) + 1
\end{lstlisting}
\sysname then \textit{specializes} this candidate to \lstinline{p} (line 16), the argument
to the conclusion of \lstinline{le_ind}. This produces a patch:

\begin{lstlisting}
  patch n m p H0 H1 := (@\vspace{-0.04cm}@)
    (fun (H : n <= (@\diff{p}@)) => le_plus_trans n (@\diff{p}@) 1 H)(@\vspace{-0.04cm}@)
  : (@\ltacforall@) n m p, n <= m $\rightarrow$ m <= p $\rightarrow$ n <= (@\diff{p}@) -> n <= (@\diff{p}@) + 1
\end{lstlisting}
The user can then use \lstinline{patch} to fix other broken proofs.
For example, given a proof that applies \lstinline{old}, the user can use \lstinline{patch} to prove the same conclusion
by applying \lstinline{new}:

\begin{lstlisting}[language=coq]
  (@\succeeds{apply old.}@)(@\vspace{-0.1cm}@)
  (@\diff{apply patch.}@) (@\succeeds{apply new.}@)
\end{lstlisting}
This can happen automatically through hint databases.

This simple example uses only two transformations. The other transformations help turn candidates
into patches in similar ways. We discuss all of this in detail later.
Later we will see real-world examples that demonstrate more configurations, too.
For now let's talk about the scope more.

\subsection{Scope: Changes in Content}
\label{sec:pumpkin-scope}

% TODO somewhere distinguish between prototype and suite of tools meaningfully
The 2018 \sysname prototype searches for patches to proofs broken by changes in the content of programs and specifications.
The corresponding differencing algorithms run in response to a breaking change in the content of a program or specification. % TODO clarify ``certain''?
They focus in particular on changes that do not add, remove, or rearrange any assumptions.
Chapter~\ref{TODO} explains an extension to \sysname that supports a broad class of
changes in datatypes that may change in those ways.

Basically the main barrier here is that this produces a function that the user must apply.
Thus it can't handle changes that move things around, as these need to be transformed directly.
Mention the particular configurations implemented here honestly, but then note that general approach is cool when it produces a function.

\subsection{Differencing: Candidates from Examples}
\label{sec:pumpkin-spec-diff}

Differencing takes as inputs $\ldots$ and returns $\ldots$:

\begin{itemize}
\item \textbf{Inputs}: $\ldots$, assuming:
\begin{itemize}
\item $\ldots$
\end{itemize}
\item \textbf{Outputs}: $\ldots$, guaranteeing:
\begin{itemize}
\item $\ldots$
\end{itemize}
\end{itemize}

other details like what is proven or whatever (here, maybe the list of differencing procedures actually supported?)

\iffalse
\paragraph{Input: Example Patched Proof}
They look at the difference between the old and new versions of a single example patched proof in response to that change.
Old and new version of example patched proof.
%\sysname is a proof-of-concept and does not yet handle some kinds of proofs.
%In each scenario, we made minor modifications to proofs so that we could use \sysname (for example,
%using induction instead of destruction).

\paragraph{Output: Patch Candidates}
Functions that map back and forth between the old and new versions
of the example patch proof in a particular context, but do not yet generalize to other contexts.
\fi

\subsection{Transformations: Patches from Candidates}
\label{sec:pumpkin-spec-trans}

% TODO list of configurations supported?
The \sysname repository describes the classes of change that the
\sysname prototype supports.
The details of the \sysname search procedure vary by class of change.
Thus, before running the search procedure, \sysname infers a \textit{configuration} from the example change.
This configuration customizes the highlighted lines for an entire class of changes:
It determines what to diff on lines 1 and 2,
and what transformations to run to achieve what goal on line 4.
There are four transformations that turn patch candidates into reusable proof patches:

\begin{enumerate}
\item \textit{Patch specialization} to arguments
\item \textit{Patch abstraction} of arguments or functions
\item \textit{Patch inversion} to reverse a patch
\item \textit{Lemma factoring} to break a term into parts
\end{enumerate}
The configuration chooses among these strategically based on the structure of the proof term.

The transformations takes as inputs $\ldots$ and return $\ldots$:

\begin{itemize}
\item \textbf{Inputs}: $\ldots$, assuming:
\begin{itemize}
\item $\ldots$
\end{itemize}
\item \textbf{Outputs}: $\ldots$, guaranteeing:
\begin{itemize}
\item $\ldots$
\end{itemize}
\end{itemize}

other details like what is proven or whatever

\iffalse
\paragraph{Input: Patch Candidates}
They come from differencing.

\paragraph{Output: Reusable Proof Patch}
The corresponding proof term transformations then try to transform each of those candidate patch functions to a more general \textit{reusable proof patch}:
a function that can be applied with traditional proof automation to fix other proofs broken by the same change.
\fi


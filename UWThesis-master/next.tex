\section*{The Next Era: Proof Engineering for All}

% 2030? could do decades for each of this lol. I guess only if energy
% Do just 2-3 sentences per project.

Proof engineering has come a long way, but it is still accessible mostly to experts, and perhaps the occasional practitioner.
Proof repair has made proof engineering easier for experts, and a bit easier for practitioners.
But there is a lot more that we as a community can do to bring proof engineering to all: not just experts and practitioners,
but also software engineers and potential users from in other domains.

I conclude with a discussion of 12 future project ideas building up to the next era of proof engineering for all.
If any of these ideas inspire you, please work with me to bring them to life.

\subsection*{Experts}

In the future, maintaining proofs ought to be seamless for expert proof engineers.
Ideally, this means technologies---like proof repair---that automate everything but the creative parts of maintenance tasks,
leaving the creativity to the experts.
But the maintenance technologies of the future ought to reach all proof assistants,
be much more powerful,
and produce natural proof scripts in the end.

\paragraph{All Proof Assistants}
Proof repair ought to be accessible across all proof assistants.
The techniques from this thesis should be simple to apply to proof assistants with similar foundations to Coq, like Agda,
and potentially Lean.\footnote{Lean assumes an axiom that is incompatible with univalence.
It is not quite clear to me what that assumption would mean for implementing the \toolnamec transformation in Lean.
Everything else should carry over.}
But Isabelle/HOL, for example, lacks proof terms and is based on a classical logic.
One path toward proof repair for Isabelle/HOL may be to reify proof terms using
Isabelle/HOL-Proofs, apply a transformation based on the Transfer~\cite{Huffman2013} package for proof reuse, and then (as in \toolnamec) decompile those terms to automation that does 
not apply Transfer or refer to the old datatype.
Similar approaches may work for other proof assistants.

\paragraph{More Power} 
Proof repair ought to be much more powerful than it is right now.
%For example, the repair tools of the present have only limited support for proof assistant version updates;
%the repair tools of the future ought to run automatically in response to version updates, and ought to support fundamental changes in the proof term
%or proof script language.
The repair tools of the future ought to run automatically in response to proof assistant version updates.
%, and ought to support
%fundamental changes in the proof term or proof script language.
They ought to break down large changes into smaller pieces---perhaps by drawing on work in change and 
dependency management~\cite{873647, Autexier:2010:CMH:1986659.1986663, Celik:2017:IRP:3155562.3155588} to identify changes, then use the factoring transformation
to break those changes into smaller parts.
And they ought to support an even broader and more practical class of changes than they do now,
like arbitrary relations.

\paragraph{Natural Proofs}
Proof repair tools ought to produce repaired proof scripts that are natural for expert proof engineers,
regardless of style.
Toward this end, I have just begun a promising project with \kl{RanDair} and some collaborators at UMass Amherst
on integrating the prototype decompiler with the machine learning proof synthesis tool TacTok~\cite{10.1145/3428299} to rank tactic hints.
Producing more natural proofs than the prototype decompiler using fixed training data seems feasible.
More difficult---but desirable---is to train the decompiler to produce scripts that match the style of the proof engineer using the tool.

\subsection*{Practitioners}

In the future, developing and maintaining proofs ought to be much easier for practitioners to use.
Proof engineering is just starting to reach practitioners, and my proof repair tools have been a small part of that.
Workflow integration has been central to that effort, but there is a long way to go.
The repair tools of the future ought to include much more automation,
integrate smoothly into IDEs and CI tools,
and continually improve in response to feeedback from user studies.

\paragraph{More Automation}
Proof repair tools ought to include much more automation.
They ought to elegantly support repair over large libraries when many changes occur at once,
while imposing little additional effort on the proof engineer.
They ought to be simple to extend with new optimizations, all while preserving correctness.
One promising path to these ends is integrating the \toolnamec transformation with \textit{e-graphs}~\cite{egraph1},
a data structure %that is used in the constraint solver and rewrite system communities 
for managing equivalences
built with these kinds of problems in mind.
E-graphs were recently adapted to express path equality in cubical~\cite{egraph6}---a perfect fit for the \toolnamec transformation.
E-graphs in other proof assistants, like those in Lean~\cite{selsam:lean}, could help with similar automation for repair tools for other proof assistants.

\paragraph{Smooth Integration}
Proof repair tools ought to integrate smoothly into IDEs like Proof General~\cite{proofgeneral},
or into continuous integration (CI) systems like Travis~\cite{travis}.
CI support hinges on the ability to break large changes into smaller pieces.
At the level of the IDE, recording changes during development may help circumvent this problem.
The infrastructure from the \textsc{REPLica} user study may be a good start for IDE integration.
Program repair tools like CatchUp!~\cite{Henkel:2005:CCR:1062455.1062512} with existing IDE integration may provide inspiration
for both infrastructure and user experience.

\paragraph{User Feedback} repair challenge, user studies ideas (PUMPKIN PATCH, REPLICA, panel w/ Benjamin Pierce, QED at large). (maybe look for more ideas, this can be merged with integration if need be).

\subsection*{Software Engineers}

Unifying theme: mixed methods verification, or the 2030 vision from Twitter thread. Some examples:

\paragraph{Gradual Verification} A continuum from testing to verification, tools to help with that.

\paragraph{Tool-Assisted Proof Development} Tool-assisted development to follow good design principles for verificattion (James Wilcox conversation, final REPLICA takeaway).

\paragraph{Specification Inference} Analysis to infer specs (TA1).

\subsection*{New Domains}

Unifying theme: collaboration, new abstractions for new domains). Some examples:

\paragraph{Machine Learning} Fairification \& other ML correctness properties. Some stuff here but more.

\paragraph{Cryptography} Lots of stuff here but not thinking broadly enough. What about cryptographic proof systems? ZK and beyond. Recall email thread.

\paragraph{Something Else} Look for more in survey paper, email, DARPA TAs, Twitter. Healthcare perhaps? % https://twitter.com/TaliaRinger/status/1373747841944883201

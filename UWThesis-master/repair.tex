\section{Proof Repair}
\label{sec:mot-rep}

\textit{Proof repair} is a new kind of proof automation that automatically fixes broken proofs in response to changes.
In contrast with traditional proof automation, proof repair views proofs as fluid entities.
The name of proof repair is inspired by program repair~\cite{Monperrus:2018:ASR:3177787.3105906, Gazzola:2018:ASR:3180155.3182526},
or automatically fixing bugs in programs.
But my proof repair tools work differently from program repair tools, 
using a combination of semantic differencing and program transformations (Section~\ref{sec:how}).
All of this happens over low-level proof terms in \kl{Gallina}---and this is the key to success (Section~\ref{sec:infocert}).

\subsection{How Proof Repair Works}
\label{sec:how}

Recall thesis: Changes in programs, specifications, and proofs carry information that a tool can extract, generalize, and apply to fix other proofs broken by the same change. A tool that automates this can save work for proof engineers relative to reference manual repairs in practical use cases.

Proof repair accomplishes this using a combination of differencing and program transformations.

Differencing extracts the information from the change in program, specification, or proof.

The transformations then generalize that information to a more general fix for other proofs broken by the same change.

The details of applying the fix vary by the kind of fix, as we'll soon see.

\subsection{The Key to Proof Repair}
\label{sec:infocert}

Crucially, all of this happens over the proof terms in this rich language we saw in the Development section. This is kind of the key insight that makes it all work.

This is great because this language gives us so much information and certainty. This helps us with two of the biggest challenges from 
program repair. (generals related work---but can just refer to the related work section for more information here)

But it's also challenging because this language is so unforgiving. Plus, in the end, we need these tactic proofs, not just proof terms. So we can't just reuse program repair tools. (generals related work)

The way that proof repair works is quite different from the way that program repair works.
That is, many program repair tools work by running tests or the programs themselves and looking at the output,
and many use fitness functions evaluate candidate patches that are almost correct.
But there are not natural analogues of this in the world of proofs:
there are often no tests, it is not possible to just run the proof, and there is not a natural 
fitness function that describes what it means for a patch to a proof to be almost correct.

In addition, proof engineers write proofs in this high-level language of tactics.
Each of these tactics is really a search procedure for a proof term, so it is not straightforward to apply
typical program repair techniques to fix a blah blah blah.

So next two chapters will show two tools in my tool suite that work this way, how they handle these challenges, and how they save work.
They will have parallel organization (informal for now but hopefully gives you a sense of what I'm thinking):

\begin{enumerate}
\item \textbf{Motivating Example}: an example change that motivates the class of repairs the tool supports.
\item \textbf{Approach}: a specification for the repair tool, including what kind of changes it supports, where it looks to extract \& generalize changes, what the extracted
\& generalized change actually is, and (for the second tool) how it applies those changes. expected inputs and outputs, plus fit to thesis frame.
\item \textbf{Differencing}: design of differencing algorithms.
\item \textbf{Transformation}: design of proof term transformations.
\item \textbf{Implementation}: how this is actually implemented for Coq.
\item \textbf{Results}: proof that this can save work relative to reference manual repairs.
\item \textbf{Conclusion}: conclusion, limitations, lessons.
\end{enumerate}


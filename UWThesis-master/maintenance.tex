\section{Proof Maintenance}
\label{sec:mot-mai}

What does it mean to \textit{maintain} a verified system?
Like all software systems, verified systems evolve over time.
The difference is that, for verified systems, the proofs must evolve alongside the rest of the system (Section~\ref{sec:changes}).
Proof engineers typically use development processes to make proofs less likely to break in the face of these changes (Section~\ref{sec:processes}).
Still, even with these development processes, breaking changes happen all the time, even for experts (Section~\ref{sec:irl}).
All of this points to a need for change-aware proof automation---that is, proof repair (Section~\ref{sec:thus-repair}).

\subsection{Breaking Changes}
\label{sec:changes}

At its core, a verified system has three parts, corresponding to the workflow from Section~\ref{sec:mot-dev}:

\begin{enumerate}
\item programs,
\item specifications, and
\item proofs.
\end{enumerate}
As verified systems evolve over time, both programs and specifications can change.
Either of these changes can break existing proofs.

Consider the example from Section~\ref{sec:verif}.
We had two choices for the specification of \lstinline{zip_preserves_length}.
We chose the weaker specification on the left of Figure~\ref{fig:zip-pres}.
This gives us some freedom in how we implement our \lstinline{zip} function.
At some point, we may wish to change \lstinline{zip}, and update our proof so that it still holds.
Alternatively, we may wish to port our development to use the stronger specification on the right of Figure~\ref{fig:zip-pres}
We may even wish to use a datatype more expressive than \lstinline{list}, as we will see in Section~\ref{TODO}. % TODO
Any of these changes can break proofs in our proof development.

\paragraph{Changing our Program}

Our specification of \lstinline{zip_preserves_length} gives us some freedom to change how our \lstinline{zip} function from Figure~\ref{fig:zip} behaves on edge cases,
when the lengths of input lists are not equal.
Suppose we change our \lstinline{zip} function to always return \lstinline{nil} in those cases,
by just returning the old behavior when the lengths are equal, and otherwise returning \lstinline{nil}.
To do this, we rename our old \lstinline{zip} function to be \lstinline{zip_same_length}.
We then define a new \lstinline{zip} function that breaks into those two cases, calling \lstinline{zip_same_length}
when the lengths are equal, and otherwise returning \lstinline{nil}:

\begin{lstlisting}
zip {T$_1$} {T$_2$} (l$_1$ : list T$_1$) (l$_2$ : list T$_2$) : list (T$_1$ * T$_2$) :=
  sumbool_rect (fun _ => list (T$_1$ * T$_2$))
    (fun (_ : length l$_1$ = length l$_2$) =>
      zip_same_length l$_1$ l$_2$)
    (fun (_ : length l$_1$ <> length l$_2$) =>
      nil)
    (eq_dec (length l$_1$) (length l$_2$)).
\end{lstlisting}
where \lstinline{sumbool_rect} is an eliminator that lets us break into these two cases, and 
\lstinline{eq_dec} says that equality is decidable over natural numbers (that is, any two numbers are either equal or not equal).

% TODO we want this to work with PUMPKIN PATCH original, but will need some programming time for that to actually happen...

Our theorem \lstinline{zip_preserves_length} still holds, but after changing our program, the \textit{proof} that it holds breaks.
We can fix it by adding the \codediff{highlighted} tactics:

\begin{lstlisting}
Proof.
  (@\codediff{intros. unfold zip.}@)
  (@\codediff{induction (eq\_dec (length l$_1$) (length l$_2$)); try contradiction.}@)
  (@\codediff{simpl. revert a. revert H. revert l$_2$.}@)
  induction l$_1$ as [|t$_1$ tl$_1$ IHtl$_1$].
  - auto.
  - intros l$_2$. induction l$_2$ as [|t$_2$ tl$_2$ IHtl$_2$].
    + intros H. auto.
    + intros H. simpl. rewrite IHtl1; auto.
Defined.
\end{lstlisting}
If we have many proofs about \lstinline{zip}, they may break in similar ways, and require similar patchwork.

\paragraph{Changing our Specification}
Suppose we had instead chosen the stronger specficiation on the right of Figure~\ref{fig:zip-pres},
and kept our \lstinline{zip} function the same.
We can update our proof accordingly, but after changing this specification, other proofs may break.
For example, if we had written a lemma for the \lstinline{cons} case:

\begin{lstlisting}
Lemma zip_preserves_length_cons :
  $\forall$ {T$_1$ : Type} {T$_2$ : Type} (l$_1$ : list T$_1$) (l$_2$ : list T$_2$) (t$_1$ : T$_1$) (t$_2$ : T$_2$),
    length l$_1$ = length l$_2$ $\rightarrow$
    length (zip (cons t$_1$ l$_1$) (cons t$_2$ l$_2$)) = S (length l$_1$).
Proof.
  intros T$_1$ T$_2$ l$_1$ l$_2$ t$_1$ t$_2$ H.
  simpl. f_equal.
  rewrite zip_preserves_length; auto.
Defined.
\end{lstlisting}
that followed by \lstinline{zip_preserves_length},
then after the change, this proof would break.

We would have two choices to fix it. Either we could leave our specification alone,
and fix our proof.
In that case,
the proof would look like this instead (with the difference \codediff{highlighted}):

\begin{lstlisting}
Proof.
  intros T$_1$ T$_2$ l$_1$ l$_2$ t$_1$ t$_2$ H.
  simpl. f_equal.
  (@\codediff{rewrite $\leftarrow$ min\_id. rewrite H at 2.}@)
  apply zip_preserves_length; auto.
Defined.
\end{lstlisting}
The extra tactics correspond to an extra proof obligation:
we must now show that \lstinline{length l}$_1$\lstinline{ = min (length l}$_1$\lstinline{) (length l}$_2$\lstinline{)}.
This holds by the lemma \lstinline{min_id} from the Coq standard library, combined with the hypothesis that says that \lstinline{length l}$_1$\lstinline{= length l}$_2$.

Alternatively, we could strengthen the specification of that lemma as well, and leave the proof alone:

\begin{lstlisting}
Lemma zip_preserves_length_cons :
  $\forall$ {T$_1$ : Type} {T$_2$ : Type} (l$_1$ : list T$_1$) (l$_2$ : list T$_2$) (t$_1$ : T$_1$) (t$_2$ : T$_2$),
    length (zip (cons t$_1$ l$_1$) (cons t$_2$ l$_2$)) = S (min (length l$_1$) (length l$_2$)).
Proof.
  intros T$_1$ T$_2$ l$_1$ l$_2$ t$_1$ t$_2$.
  simpl. f_equal.
  apply zip_preserves_length_alt; auto.
Defined.
\end{lstlisting}
But this could continue to break other downstream proofs that depend on \lstinline{zip_preserves_length_cons},
causing a cascading effect of change.

\subsection{Building Robust Proofs}
\label{sec:processes}

There are a lot of development processes people use to make proofs less likely to break to begin with (survey paper)

affinity lemmas and reference to \lstinline{zip} example.

tactics and how they relate

\iffalse
In that case, it may help us to define a more general \lstinline{patch} corresponding to the change:

\begin{lstlisting}
Lemma patch:
  forall {T$_1$} {T$_2$} (l$_1$ : list T$_1$) (l$_2$ : list T$_2$) (P : list (T$_1$ * T$_2$) $\rightarrow$ Type),
    length l$_1$ = length l$_2$ $\rightarrow$ 
    P (zip_same_length l$_1$ l$_2$) $\rightarrow$ 
    P (zip l$_1$ l$_2$).
Proof.
  intros. unfold zip.
  induction (eq_dec (length l$_1$) (length l$_2$)); simpl; auto.
  apply False_rect. auto.
Defined.
\end{lstlisting}
This says that it is possible to get between \textit{any} proof about \lstinline{zip_same_length}
and \textit{any} proof about \lstinline{zip}.
We can apply this in proofs about \lstinline{zip}:

\begin{lstlisting}
Proof.
  (@\codediff{intros. apply patch; auto.}@)
  (@\codediff{revert H. revert l$_2$.}@)
  induction l$_1$ as [|t$_1$ tl$_1$ IHtl$_1$].
  - auto.
  - intros l$_2$. induction l$_2$ as [|t$_2$ tl$_2$ IHtl$_2$].
    + intros H. auto.
    + intros H. simpl. rewrite IHtl1; auto.
Defined.
\end{lstlisting}
In Section~\ref{TODO}, I will show how \sysname can automatically extract patches like \lstinline{patch} % TODO would be great if it worked for this example
from example changes in proofs.
\fi

\subsection{Even Experts are Human}
\label{sec:irl}

Still, even with these development processes, breaking changes happen all the time, even for experts.

But still, even with these, the reality: This happens all the time (REPLICA)

And in fact not just after developing a proof, but during development too (REPLICA)

And breaks proofs even for experts (REPLICA)

And it's an extra big problem when you have a large development and the changes are outside of your control

Hence Social Processes

\subsection{The Need for Repair}
\label{sec:thus-repair}

Why automation breaks, even with good development processes

Hence proof repair---smarter automation

% TODO for now, just a copy-paste of analytics original paper, including the bib---will change soon

%\input{maintenance/introduction}

%\input{maintenance/plugin}

%\input{maintenance/study}

%\input{maintenance/discussion}

%\input{maintenance/related}


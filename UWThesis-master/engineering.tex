\section{Proof Engineering for Program Verification}
\label{sec:mot-prog}

% From QED at large:
Formal verification of a program can improve actual and perceived reliability.
It can help the programmer think about the desired and actual behavior of the program,
perhaps finding and fixing bugs in the process~\cite{murraybp}.
It can make explicit which parts of the system are trusted, and further decrease the burden
of trust as more of the system is verified.

One noteworthy program verification success story is the CompCert~\cite{Leroy:POPL06, Leroy2009} verified optimizing C compiler.
Both the back-end and front-end compilation passes
of CompCert have been verified, ensuring the correctness of their composition~\cite{Kaestner2017}.
CompCert has stood up to the trials of human trust: it has been used, for example, to compile code for safety-critical flight control software~\cite{Frana2011}.
It has also stood up to rigorous testing: while the test generation tool Csmith~\cite{Yang2011} found 
79 bugs in GCC and 202 bugs in LLVM, it was unable to find any bugs in the verified parts of CompCert.
%This demonstrated the empirical reliability of CompCert, which in turn further increased confidence in its reliability.

CompCert, however, was not a simple endeavor: the original development comprised of approximately 35,000 lines of Coq code;
functionality accounted for only 13\% of this, while specifications and proofs accounted for the other 87\%.
This is not unusual for large proof developments. The initial correctness proofs for an OS microkernel,
for example, consisted of 480,000 lines of specifications and proofs~\cite{Klein2014micro}.
Proof engineering makes it possible to develop proofs at this scale,
bringing all of the benefits of verification to large systems.
See the survey paper for more information.


\section{Proof Development}

% TODO this is all shitty first draft text

something

\subsection{Why Develop Proofs}

%Cartoon version of development: program, spec, proof
Formal verification of a program can improve actual and perceived reliability.
It can help the programmer think about the desired and actual behavior of the program,
perhaps finding and fixing bugs in the process~\cite{murraybp}.
It can make explicit which parts of the system are trusted, and further decrease the burden
of trust as more of the system is verified.

One noteworthy program verification success story is the CompCert~\cite{Leroy:POPL06, Leroy2009} verified optimizing C compiler.
Both the back-end and front-end compilation passes
of CompCert have been verified, ensuring the correctness of their composition~\cite{Kaestner2017}.
CompCert has stood up to the trials of human trust: it has been used, for example, to compile code for safety-critical flight control software~\cite{Frana2011}.
It has also stood up to rigorous testing: while the test generation tool Csmith~\cite{Yang2011} found 
79 bugs in GCC and 202 bugs in LLVM, it was unable to find any bugs in the verified parts of CompCert.
%This demonstrated the empirical reliability of CompCert, which in turn further increased confidence in its reliability.

CompCert, however, was not a simple endeavor: the original development comprised of approximately 35,000 lines of Coq code;
functionality accounted for only 13\% of this, while specifications and proofs accounted for the other 87\%.
This is not unusual for large proof developments. The initial correctness proofs for an OS microkernel,
for example, consisted of 480,000 lines of specifications and proofs~\cite{Klein2014micro}.
Proof engineering makes it possible to develop proofs at this scale,
bringing all of the benefits of verification to large systems.

\subsection{How to Develop Proofs}

\begin{figure}[ht]
  \centering
{\footnotesize
\begin{tikzpicture}[>=stealth',semithick]

\begin{scope}
\node[ellipse, draw=black, inner ysep=8pt, inner xsep=5pt] (user) { user };
\end{scope}

\begin{scope}[xshift=5.5cm]
\node[rectangle, draw=black, minimum width=6.5cm, minimum height=2cm] (coq) { };
\node[rectangle, draw=black, minimum height=1.5cm, fill=lightgray, xshift=-2cm] (engine) { logic engine };
\node[rectangle, draw=black, xshift=1.8cm] (checker) { proof checker };
\node[xshift=1.7cm, yshift=0.7cm] (sys) { proof assistant };
\end{scope}

\begin{scope}[xshift=9.5cm]
\node[yshift=0.6cm] (ack) {\checkmark};
\node[yshift=-0.6cm,xshift=-0.1cm] (nack) {\cross};
\end{scope}

\draw[->, thick] (user.north east) to node[xshift=-0.2cm, yshift=0.2cm] {tactics} ([yshift=0.33cm]engine.west);
\draw[->, thick] ([yshift=0.38cm]engine.south west) to node[xshift=-0.2cm, yshift=-0.2cm] {subgoals} (user.south east);

\draw[->, thick] (engine.east) to node[yshift=0.2cm] {proof} (checker.west);

\draw[->, thick] (checker.east) to (ack.south west);
\draw[->, thick] (checker.east) to (nack.north west);

\end{tikzpicture}
}
\caption{Typical proof assistant workflow, adapted from \cite{pa-history-geuvers-sadhana09}.}
\label{fig:workflow}
\end{figure}

The first step to developing proofs is choosing a proof assistant.
In this thesis, when I write about proof assistants in general, I consider proof assistants that satisfy the \textit{de Bruijn criterion}~\cite{Barendregt2002,Barendregt2351}, which requires that they produce proof objects that a small proof-checking kernel can verify.
This proof object is the low-level representation I wrote about in the introduction.
The general workflow of such tools is illustrated in Figure~\ref{fig:workflow}. Examples include Coq, Isabelle/HOL~\cite{isabelle}, 
HOL Light~\cite{hollight}, and Agda~\cite{agda}; I do not consider program verifiers, theorem provers, and constraint solvers such as Dafny~\cite{Leino2010}, ACL2~\cite{acl2}, and Z3~\cite{z3}.

The details of proof development look slightly different by proof assistant.
The proof assistant that I focus on in this thesis will be the Coq proof assistant,
since this is the proof assistant that \toolname is implemented for.
Proof development in Coq is similar to proof development in Lean.
Other proof assistants sometimes diverge a bit.
More details on that either here or later.
Let's take a look at an example.

For the sake of this thesis, I will not demonstrate proof development on a C compiler or on an OS microkernel.
Instead, I will start by demonstrating a simple proof development: 
that the list zip function preserves its length.
This is a toy example, but it is worth noting that large proof developments like compilers and microkernels
are often made up of many of these smaller examples built on top of each other.

Slightly less brief overview of Coq and its foundations and automation and so on (including proof terms), going through a running example of proof development in Coq


\subsection{The Workflow}
\label{sec:mot-workflow}

\paragraph{Preliminaries}
Before we can write our small verified program,
we need the \lstinline{list} datatype and the \lstinline{length} function.
To write the \lstinline{length} function, we need the \lstinline{nat} datatype of unary natural numbers.
All of these can be found in the Coq standard library.

Each of \lstinline{nat} and \lstinline{list} in Gallina is an \textit{inductive type}:
it is defined by its \textit{constructors} (ways of constructing a term with that type).
A \lstinline{nat}, for example:

\begin{lstlisting}
Inductive nat :=
| O : nat
| S : nat $\rightarrow$ nat.
\end{lstlisting}
is either \lstinline{0} or the successor \lstinline{S} of another \lstinline{nat};
these are the two constructors of \lstinline{nat}.
A \lstinline{list} is similar:

\begin{lstlisting}
Inductive list (T : Type) :=
| nil : list T
| cons : T $\rightarrow$ list T $\rightarrow$ list T.
\end{lstlisting}
There are two differences: \lstinline{list} is polymorphic over some type \lstinline{T} (so we can have a list of natural numbers,
for example, written \lstinline{list nat}), and the second constructor adds a new element of the type \lstinline{T} to the front of the list.
Otherwise, \lstinline{list} also has two constructors, \lstinline{nil} and \lstinline{cons}, where \lstinline{nil} represents the empty list,
and \lstinline{cons} sticks a new element in front of any existing list.

Every inductive type in Gallina comes equipped with an \textit{eliminator} or induction principle
that the proof engineer can use to write functions and proofs about the datatype.
For example, the eliminator for \lstinline{nat} is the standard induction principle for natural numbers,
which Coq calls \lstinline{nat_rect}: % TODO footnote about nat_ind, nat_rec, nat_rect

\begin{lstlisting}
nat_rect :
  $\forall$ (P : nat $\rightarrow$ Type), (* motive *)
    P O $\rightarrow$ (* base case *)
    ($\forall$ (n : nat), P n $\rightarrow$ P (S n)) $\rightarrow$ (* inductive case *)
    $\forall$ (n : nat), P n.
\end{lstlisting}
This eliminator states that a statement \lstinline{P} (called the inductive \textit{motive}) about the natural numbers
holds if it holds for \lstinline{O} in the base case and, in the inductive case,
assuming it holds for some \lstinline{n}, it also holds for the successor \lstinline{S n}.
The eliminator for \lstinline{list} is similar:

\begin{lstlisting}
list_rect :
  $\forall$ (T : Type) (P : list T $\rightarrow$ Type), (* motive *)
    P (nil T) $\rightarrow$ (* base case *)
    ($\forall$ (t : T) (tl : list T), P tl $\rightarrow$ P (cons T t tl)) $\rightarrow$ (* inductive case *)
    $\forall$ (l : list T), P l.
\end{lstlisting}
but with an argument corresponding to the parameter \lstinline{T} over which \lstinline{list} is polymorphic,
and with an additional argument corresponding to the new element in the inductive case.

\begin{figure}
\begin{minipage}{0.42\textwidth}
\begin{lstlisting}
Fixpoint length T l :=
  match l with
  | nil _ => O
  | cons _ t tl =>
      S (length T tl)
  end.
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.54\textwidth}
\begin{lstlisting}
Definition length T l :=
  list_rect T (fun _ => nat)
    O
    (fun t tl (length_tl : nat) =>
      S length_tl)
    l.
\end{lstlisting}
\end{minipage}
\caption{The list \lstinline{length} function, defined both by pattern matching and recursion (left) and using the eliminator \lstinline{list_rect} (right).}
\label{fig:length}
\end{figure}

We can use these eliminators to write functions and proofs, like the \lstinline{length} function we will need for our proof development (Figure~\ref{fig:length}, right).
More standard is to write functions using pattern matching and guarded recursion, like the \lstinline{length} function from the Coq standard library (Figure~\ref{fig:length}, left).
Both of these two functions behave the same way, but the function on the left is perhaps a bit easier to understand from a traditional programming background:
the \lstinline{length} of the empty list \lstinline{nil} is \lstinline{0}, and the length of any other list
is just the successor (\lstinline{S}) of the result of recursively calling \lstinline{length} on everything but the first element of the list.
Indeed, \lstinline{list_rect}---like all eliminators in Coq---is just a constant that refers to a function itself defined using pattern matching and guarded recursion.
In fact, eliminators are equally expressive to pattern matching and guarded recursion~\cite{TODO}. % the general translation is hard and Coq sucks at eliminator gen though

For the sake of this thesis, however, I will assume \intro{primitive eliminators}: eliminators that are a part of the core syntax and theory itself,
and that do not reduce to terms that use pattern matching and guarded recursion.
Likewise, when I show Gallina code, I will always use functions that apply eliminators rather than pattern matching, like the \lstinline{length} function from Figure~\ref{fig:length}
on the right.
To handle practical code that uses pattern matching and guarded recursion,
I preprocesss the code using a tool by my coauthor Nate Yazdani (more about this later). % TODO make this more formal, can say limitations, can say generates length above, wahtever
In the rest of the paper, I skip this preprocessing step in examples, but I describe it more in the implementation section later.

With that in mind, we can now write our small verified program.

\begin{figure}
\begin{lstlisting}
Definition zip {a} {b} : list a -> list b -> list (a * b)%type :=
  fix zip arg_0__ arg_1__
        := match arg_0__, arg_1__ with
           | nil, _bs => nil
           | _as, nil => nil
           | cons a as_, cons b bs => cons (pair a b) (zip as_ bs)
  end. (* TODO convert to eliminators *)
\end{lstlisting}
\caption{The list \lstinline{zip} function from an old version of hs-to-coq~\cite{TODO}, up to renaming (TODO just say everything is, and when you introduce foundations just before this use induction principles and briefly mention fix-to-elim).}
\label{fig:zip}
\end{figure}

\paragraph{Program} Figure~\ref{fig:zip}.

\begin{figure}
\begin{lstlisting}
TODO zip_preserves_length, one version
\end{lstlisting}
\caption{TODO}
\label{fig:zip-pres}
\end{figure}

\begin{figure}
\begin{lstlisting}
TODO zip_preserves_length, another version
\end{lstlisting}
\caption{TODO}
\label{fig:zip-pres-alt}
\end{figure}

\paragraph{Specification} Figure~\ref{fig:zip-pres} or Figure~\ref{zip-pres-alt}, note art, stronger and so on, will come back to this.
Also this is where a lot of the power of the language comes in, worth noting.

\begin{figure}
\begin{lstlisting}
TODO zip_preserves_length proof
\end{lstlisting}
\caption{TODO}
\label{fig:zip-pres-proof}
\end{figure}

\paragraph{Proof} 
In Coq, those tactics are in a language called Ltac.
Each tactic is effectively a search procedure for a proof term, given the context and goals at each step of the proof.
Here is one possible proof of \lstinline{zip_preserves_length} using very simple tactics:
\begin{lstlisting}
Lemma zip_length : zip_preserves_length.
Proof.
   intros a b l1.
   induction l1 as [|_ _ IHtl1]; auto.
   induction l2 as [|_ _ IHtl2]; intros H; auto.
   simpl. rewrite IHtl1; auto.
Qed.
\end{lstlisting}
This compiles to the thing we saw before, which then type checks as expected.
But we never have to see the low-level proof term; we can reason about the high-level proof script instead.
% TODO save the better version for later so that we can show how good automation can get around some of the repair stuff
% TODO walk through and so on

Mention decompiler, explain, tease implementation section.





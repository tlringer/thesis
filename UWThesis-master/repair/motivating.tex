\section{Motivating Example}
\label{sec:patch-motivating}

% From PUMPKIN PATCH: Automation, Reimagined. Not changed, yet. Needs some work. Outstanding:
% 1. Can we link to code and show Patch Proof on this example?
% 2. User didn't fix all of the library functions, even; paper didn't mention that.
% 3. Reframe so less visionary?
% 4. Flow with thesis frame?
% TODO for real, get this working in vanilla pumpkin patch also

Traditional proof automation considers only the current state of programs, specifications, and proofs.
This is a missed opportunity: verified software systems are rarely static.
Like unverified systems, verified systems evolve over time.

With traditional proof automation, the burden of change largely falls on proof engineers.
Proof repair by example shows that this does not have to be true.
It is a form of proof automation that views programs, specifications, and proofs as fluid entities.
When a program or specification changes and this breaks many proofs,
it extracts information found in the difference between the old and new versions of a single patched proof,
and generalizes that to a \emph{reusable patch} that can fix other proofs broken by the same change.

\paragraph{Without Proof Repair} Experienced proof engineers use design principles and custom tactics to make proofs
resilient to change. These techniques are useful for large proof developments, but they
place the burden of change on the proof engineer. This can be problematic
when change occurs outside of the proof engineers's control.

\begin{figure*}
\begin{minipage}{0.55\textwidth}
\centering
\lstset{language=coq, aboveskip=0pt, belowskip=0pt}
\lstinputlisting[firstline=1, lastline=3]{repair/izr.tex}
\lstinputlisting[backgroundcolor=\color{orange!35},firstline=4,lastline=5]{repair/izr.tex}
\lstinputlisting[firstline=6, lastline=6]{repair/izr.tex}
\end{minipage}
\hfill
\begin{minipage}{0.44\textwidth}
\centering
\lstset{language=coq, aboveskip=0pt, belowskip=0pt}
\lstinputlisting[firstline=8, lastline=10]{repair/izr.tex}
\lstinputlisting[backgroundcolor=\color{orange!35},firstline=11,lastline=12]{repair/izr.tex}
\lstinputlisting[firstline=13, lastline=13]{repair/izr.tex}
\end{minipage}
%\setlength{\belowcaptionskip}{-2pt}
\caption[Caption]{Old (left) and new (right) definitions of \lstinline{IZR} in Coq.
The old definition applies injection from naturals to reals and conversion of positives to
naturals; the new definition applies injection from positives to reals.}
\label{fig:izr}
\end{figure*}

Consider a commit from the Coq 8.7 release~\cite{coq87commit}. 
This commit redefined injection from integers to reals (Figure~\ref{fig:izr}).
This change broke 18 proofs in the standard library. 

The Coq standard library developer who committed the change fixed most of the broken proofs,
but failed to fix some of them. % TODO how many?
The developer then made an additional 12 commits to address the change in \lstinline{coq-contribs},
a regression suite of projects that the Coq standard library developers maintain as Coq versions change.
Many of these changes were simple. For example, the developer wrote a lemma that describes the change:

\lstset{language=coq, aboveskip=3pt, belowskip=3pt}
\begin{lstlisting}
  Lemma INR_IPR : (@\ltacforall@)p, INR (Pos.to_nat p) = IPR p.
\end{lstlisting}
The developer then used this lemma to fix broken proofs within the standard library. 
For example, the proof of the lemma \lstinline{plus_negative_positive} broke on this line: % TODO check to make sure this is the right theorem name IRL

\begin{lstlisting}
  (@\fails{rewrite Pos2Nat.inj\_sub by trivial.}@)
\end{lstlisting}
It succeeded with the lemma:

\begin{lstlisting}
  rewrite (@\diff{$\leftarrow$ 3!INR\_IPR}@), (@\succeeds{Pos2Nat.inj\_sub by trivial.}@)
\end{lstlisting}

These changes were outside-facing: proof engineers had to make similar changes to their own proofs when
they updated their developments from Coq 8.6 to Coq 8.7. The Coq standard library developer could have updated some tactics to account for this, but it 
would have been impossible to account for every tactic that proof engineers could use.
Furthermore, while the library developer responsible for the changes knows about
the lemma that describes the change, the proof engineer does not. The proof engineer must determine
how the definition has changed and how to address the change, perhaps by reading documentation or by
talking to the Coq standard library developers. 

\paragraph{With Proof Repair} When a proof engineer updates the Coq standard library, a proof repair tool can determine
that the definition has changed, then analyze changes in the standard library and in \lstinline{coq-contribs}
that resulted from the change in definition (in this case, rewriting by the lemma).
It can extract a reusable patch from those changes, which it can automatically apply within broken user proofs.
The proof engineer never has to consider how the definition has changed.


\chapter{Related Work}

% TODO whatever else isn't here yet, and some of this might be factored out or partially factored out---all papers, including survey, plus generals

\section{Programs}

\subsection*{Program Refactoring} 

Refactoring~\cite{Mens:2004:SSR:972215.972286}.

\subsection*{Program Repair} 

% From PUMPKIN Pi, unchanged

Proof repair can be viewed as a form of \textit{program repair}~\cite{Monperrus:2018:ASR:3177787.3105906, Gazzola:2018:ASR:3180155.3182526}
for proof assistants.
Proof assistants like Coq are a good fit for program repair: A recent paper~\cite{Qi:2015:APP:2771783.2771791} 
recommends that program repair tools draw on extra information
such as specifications or example patches. In Coq, specifications and examples 
are rich and widely available: specifications thanks to dependent types,
and examples thanks to constructivism.

% From PUMPKIN PATCH, unchanged

Program repair tools for 
languages with non-dependent type 
systems~\cite{Pei:2014:APR:2731750.2731779, Long:2016:APG:2837614.2837617, Le:2017:SSS:3106237.3106309, Mechtaev:2016:ASM:2884781.2884807, Monperrus2015} 
may have applications in the context of a dependently typed language.
Similarly, our work may have applications within program repair in these languages:
Future applications of our approach may repurpose it to repair programs for functional languages.

\subsection*{Ornaments}

% From DEVOID, unchanged

\toolnameb automates discovery of and lifting across algebraic ornaments in a higher-order dependently typed language.
In the decade since the discovery of ornaments~\cite{mcbride}, there have been a number
of formalizations and embedded implementations of ornaments~\cite{Dagand:2013:CTO:2591370.2591396, ko2013relational, dagand2014transporting, ko2016programming, dagand2017essence}.
\toolnameb is the first tool for ornamentation to operate over a non-embedded dependently typed language.
It essentially moves the automation-heavy approach of Ornamentation in ML~\cite{Williams2017},
which operates on non-embedded ML code, into the type theory that forms the basis of theorem provers like Coq. 
In doing so, it takes advantage of the properties of algebraic ornaments~\cite{mcbride}.
It also introduces the first search algorithm to identify ornaments, which in the past 
was identified as a ``gap'' in the literature~\cite{ko2016programming}.

\subsection*{Programming by Example}

% From PUMPKIN PATCH, unchanged

Our approach generalizes an example that the programmer provides.
This is similar to programming by example, a subfield of 
program synthesis~\cite{DBLP:journals/ftpl/GulwaniPS17}. 
This field addresses different challenges in different logics,
but may drive solutions to similar problems in a dependently typed language.

\subsection*{Differencing \& Incremental Computation}

% From PUMPKIN PATCH, unchanged

Existing work in differencing and incremental computation may help 
improve our semantic differencing component.
Type-directed diffing~\cite{Miraldo:2017:TDS:3122975.3122976}
finds differences in algebraic data types.
Semantics-based change impact analysis~\cite{Autexier:2010:SCI:1860559.1860580} models semantic differences
between documents.
Differential assertion checking~\cite{differential-assertion-checking-2} analyzes different
versions of a program for relative correctness with respect to a specification.
Incremental $\lambda$-calculus~\cite{Cai:2014:TCH:2594291.2594304} introduces a general model for program changes.
All of these may be useful for improving semantic differencing.

\section{Proofs}

\subsection*{Proof Reuse}

% From PUMPKIN PATCH, mostly unchanged

Our approach reimagines the problem of proof reuse in the context of proof automation.
While we focus on changes that occur over time, traditional proof reuse techniques can help
improve our approach.

Proof reuse for extended inductive types~\cite{Boite2004} adapts proof obligations
to structural changes in inductive types. Later work~\cite{Mulhern06proofweaving} proposes a method
to generate proofs for new constructors. These approaches may be useful when extending the differencing
component to handle structural changes. Existing work in theorem reuse and proof generalization~\cite{Felty1994, pons00, Johnsen2004} abstracts existing proofs for reusability, and may be useful
for improving the abstraction component.
Our work focuses on the components critical to searching for patches; these complementary approaches
can drive improvements to the components.

% From PUMPKIN Pi, unchanged

A few proof reuse tools work by proof term transformation and so can be used for repair.
Existing work~\cite{Johnsen2004} describes a transformation that generalizes theorems in Isabelle/HOL.
\toolnamec generalizes the transformation from \textsc{Devoid}~\cite{Ringer2019},
which transformed proofs along algebraic ornaments~\cite{mcbride}.
Magaud \& Bertot 2000~\cite{magaud2000changing} implement a proof term transformation between
unary and binary numbers. 
Both of these fit into \toolnamec configurations,
and none suggests tactics in Coq like \toolnamec does.
The expansion algorithm from Magaud \& Bertot 2000~\cite{magaud2000changing} may help guide the design
of unification heuristics in \toolnamec.

% From PUMPKIN PATCH, unchanged

Existing work in proof reuse focuses on transferring proofs between isomorphisms,
either through extending the type system~\cite{Barthe:2001:TIP:646793.704711} or through an automatic method~\cite{Magaud2002}.
This is later generalized and implemented in Isabelle~\cite{Huffman2013} and Coq~\cite{ZimmermannH15, tabareau:hal-01559073};
later methods can also handle implications.

% From PUMPKIN Pi, unchanged

The widely used Transfer~\cite{Huffman2013} package supports proof reuse in Isabelle/HOL. % TODO somewhere discuss other proof assistants
Transfer works by combining a set of extensible transfer rules with a type inference algorithm.
Transfer is not yet suitable for repair, as it necessitates maintaining references to both datatypes.
%In addition, the proof assistant Isabelle/HOL that Transfer works for lacks both dependent types and proof terms.
One possible path toward implementing proof repair in Isabelle/HOL may be to reify proof terms using something like
Isabelle/HOL-Proofs, apply a transformation based on Transfer, and then (as in \toolname) decompile those terms to automation that does not apply Transfer or refer to the old datatype in any way.

CoqEAL~\cite{cohen:hal-01113453} transforms functions across relations in Coq,
and these relations can be more general than \toolnamec's equivalences.
However, while \toolnamec supports both functions and proofs, CoqEAL supports only simple functions
due to the problem that \lstinline{Iota} addresses.
CoqEAL may be most useful to chain with \toolnamec to get faster functions.
Both CoqEAL and recent ornaments work~\cite{williamsphd} may help with
better workflow support for changes that do not correspond to equivalences.

The \toolnamec transformation implements transport.
Transport is realizable as a function given univalence~\cite{univalent2013homotopy}.
UP~\cite{tabareau2017equivalences} approximates it
in Coq, only sometimes relying on functional extensionality.
While powerful, neither approach removes references to the old type. %making them poorly suited for repair.

Recent work~\cite{tabareau2019marriage} extends UP with 
a white-box transformation that may work for repair.
This imposes proof obligations on the proof engineer beyond those imposed by \toolname,
%that establish what is effectively the correctness criteria
%for the configuration in \toolname, while \toolname needs only that it holds metatheoretically.
and it includes neither search procedures for equivalences nor tactic script generation.
It also does not support changes in inductive structure,
instead relying on its original black-box functionality;
\lstinline{Iota} solves this in \toolname. % and is based on lessons learned from reading that article.
The most fruitful progress may come from combining these tools. % to take advantage of the benefits of both.

% From DEVOID, mostly unchanged

\toolnameb identifies and lifts proofs along a specific equivalence 
similar to that from existing ornaments work~\cite{ko2016programming}.
The need to automatically lift functions and proofs
across equivalences and other relations is a long-standing challenge for proof 
engineers~\cite{magaud2000changing, barthe2001type, magaud2003changing, huffman2013lifting, zimmermann2015automatic, cohen:hal-01414881}.
The univalence axiom from Homotopy Type Theory~\cite{univalent2013homotopy} enables transparent transport of proofs;
cubical type theory~\cite{cohen2016cubical} gives univalence a constructive interpretation. 

The problem that we solve is fundamentally about proof reuse,
which applies software reuse principles to ITPs. 
There is a wealth of work in proof reuse, from tactic languages~\cite{felty1994generalization} and logical frameworks~\cite{caplan1995logical},
to tools for proof abstraction and generalization~\cite{pons2000generalization, johnsen2004theorem},
to domain-specific methodologies~\cite{Delaware:2011:PLT:2048066.2048113} and frameworks~\cite{Delaware:2013:MLC:2429069.2429094}.

\toolnameb focuses on the specific problem of reuse
when adding fully-determined indices to types.
Other approaches to this problem include combinators which definitionally reduce to desirable terms~\cite{DBLP:journals/corr/abs-1803-08150} in the language Cedille,
and automatic generation of conversion functions in Ghostbuster~\cite{McDonell:2016:GTS:2951913.2951914} for GADTs in Haskell.
Our work focuses on a type theory different from both of these, in which the properties that allow for such combinators in Cedille are not present, and in which dependent types introduce challenges not present in Haskell.

\toolnameb is not the first tool to combine search with reuse. 
Optician~\cite{miltner2017synthesizing} synthesizes bidirectional string transformations;
a similar approach may help extend tooling to handle transformations for low-level data.
\textsc{Pumpkin Patch}~\cite{ringer2018adapting} 
searches the difference in proofs for patches that can be used to repair proofs broken by changes;
\toolnameb uses a similar approach to identify functions
that form an equivalence. The resulting tools are complementary: \toolnameb supports the addition
of indices and hypotheses, which \textsc{Pumpkin Patch} does not support; \textsc{Pumpkin Patch} supports changes
in values, which \toolnameb does not support. 

\subsection*{Proof Evolution}

% From PUMPKIN PATCH, unchanged

There is a small body of work on change and dependency management for verification,
both to evaluate impact of potential changes and maximize reuse~\cite{873647, Autexier:2010:CMH:1986659.1986663}
and to optimize build performance~\cite{Celik:2017:IRP:3155562.3155588}.
These approaches may help isolate changes, which is necessary to identify future benchmarks, integrate
with CI systems, and fully support version updates.

\subsection*{Proof Refactoring}

% From PUMPKIN Pi, mostly unchanged

Proof repair is related to proof refactoring~\cite{WhitesidePhD}. 
The proof refactoring tool Levity~\cite{Bourke12} for Isabelle/HOL has seen large-scale industrial use.
Levity focuses on a different task: moving lemmas.
Chick~\cite{robert2018} and RefactorAgda~\cite{wibergh2019} are proof refactoring tools
in a Gallina-like language and in Agda, respectively.
% that also support a few changes that can be viewed as repairs~\cite{PGL-045}.
%Chick operates over a Gallina-like language, while RefactorAgda is implemented in Agda.
These tools support primarily syntactic changes and do not have tactic support.
% changes these tools support are still primarily syntactic,
%and neither of these tools have tactic support.

A few proof refactoring tools operate directly over tactics:
POLAR~\cite{Dietrich2013} refactors proof scripts in languages based on Isabelle/Isar~\cite{Wenzel2007isar},
CoqPIE~\cite{Roe2016} is an IDE with support for simple refactorings of Ltac scripts, and
Tactician~\cite{adams2015} is a refactoring tool for switching between tactics and tacticals.
This approach is not tractable for more complex changes~\cite{robert2018}.

\subsection*{Proof Design}

% From PUMPKIN Pi, with some PUMPKIN PATCH related work integrated:

Much work focuses on designing proofs
to be robust to change, rather than fixing broken proofs.
This can take the form of design principles, like using 
information hiding techniques~\cite{Woos:2016:PCF:2854065.2854081, Klein:2014:CFV:2584468.2560537}
or any of the structures~\cite{Chrzaszcz2003, Sozeau2008, Saibi:PhD} for encoding interfaces in Coq.
CertiKOS~\cite{certikos} introduces the idea of a deep specification to ease verification of large systems.
Design principles for specific domains (like formal metatheory~\cite{Aydemir2008, Delaware2013POPL, Delaware2013ICFP})
can also make verification more tractable.
Design and repair are complementary: design requires foresight, while repair can occur retroactively.
Repair can help with changes that occur outside of the proof engineer's control,
or with changes that are difficult to protect against even with informed design.

Another approach to this is to use heavy proof automation, for example through
program-specific proof automation~\cite{Chlipala:2013:CPD:2584504}
%implementations of decision procedures~\cite{Pugh1991},
or general-purpose hammers~\cite{Blanchette2016b, Blanchette2013, Kaliszyk2014, Czajka2018}.
The degree to which proof engineers rely on automation varies, as seen in the data from a user study~\cite{replica}.
Automation-heavy proof engineering styles localize the burden of change to the automation,
but can result in terms that are large and slow to type check,
and tactics that can be difficult to debug.
While these approaches are complementary, more work is needed for \toolname to better support 
developments in this style.

\subsection*{Proof Automation}

% From PUMPKIN PATCH, unchanged:

We address a missed opportunity in proof automation for ITP: searching
for patches that can fix broken proofs.
This is complementary to existing automation techniques. Nonetheless, there is a wealth
of work in proof automation that makes proofs more resilient to change.
Powerful tactics like \lstinline{crush}~\cite{chlipala:cpdt} can make
proofs more resilient to changes. 
Hammers like Isabelle's sledgehammer~\cite{Blanchette2013} can make proofs agnostic to some low-level changes.
Recent work~\cite{coqhammer} paves the way for a hammer in Coq.
Even the most powerful tactics cannot address all changes;
our hope is to open more possibilities for automation.

Powerful project-specific tactics~\cite{chlipala:cpdt, Chlipala2013} can help prevent low-level maintenance tasks.
Writing these tactics requires good engineering~\cite{Gonthier2011} and domain-specific knowledge,
and these tactics still sometimes break in the face of change.
A future patching tool may be able to repair tactics; the debugging process
for adapting a tactic is not too dissimilar to providing an example to a tool.

Rippling~\cite{rippling} is a technique for automating inductive proofs that uses restricted rewrite rules to
guide the inductive hypothesis toward the conclusion; this may guide improvements to the
differencing, abstraction, and specialization components.
The abstraction and factoring components address specific classes of unification problems;
recent developments to higher-order unification~\cite{Miller:2012:PHL:2331097} may help
improve these components.
Lean~\cite{selsam:lean} introduces the first congruence closure algorithm for dependent type theory that
relies only on the Uniqueness of Identity Proofs (UIP) axiom. While UIP is not fundamental to Coq,
it is frequently assumed as an axiom; when it is, it may be tractable to use a similar algorithm to improve the tool.

GALILEO~\cite{bundyreasoning} repairs faulty physics theories
in the context of a classical higher-order logic (HOL); there is preliminary work extending this
style of repair to mathematical proofs. 
Knowledge-sharing methods~\cite{tgck-cicm14} can adapt some proofs across different representations of HOL.
These complementary approaches may guide extensions to support decidable domains and classical logics.



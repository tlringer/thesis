\subsection{Terms}
\label{sec:mot-coq}

% TODO knowledge indexing and so on

Coq compiles every proof script to a proof term in a rich functional programming language called \intro{Gallina}.
Gallina's foundation (Section~\ref{sec:cic}) is a rich type theory called the Calculus of Inductive Constructions (CIC$_{\omega}$).
Gallina implements (Section~\ref{sec:gallina}) this type theory with a few small differences.
Proof engineers can use Gallina to write programs, specifications, and (if they wish) proofs directly---this section
demonstrates both the foundation and the implementation on an example.

% TODO one page with, side by side, list, length, zip, zip_preserves_length, and its proof? and then a little ``zoom'' icon
% that links parts of that to inline cuts of the code that go with text flow so you don't need to keep moving back and forth

\subsubsection{Foundation: CIC$_{\omega}$}

\begin{figure*}
\small
\begin{grammar}
<i> $\in \mathbbm{N}$, <v> $\in$ Vars, <s> $\in$ \{ Prop, Set, Type<i> \}

<t> ::= <v> \hspace{0.06cm} | \hspace{0.06cm} <s> \hspace{0.06cm} | \hspace{0.06cm} $\Pi$ (<v> : <t>) . <t> \hspace{0.06cm} | \hspace{0.06cm} $\lambda$ (<v> : <t>) . <t> \hspace{0.06cm} | \hspace{0.06cm} <t> <t>
\end{grammar}
\vspace{-0.3cm}
\caption{Syntax for CoC$_\omega$ with (from left to right) variables, sorts, dependent types, functions, and application.}
\label{fig:coc-syntax}
\end{figure*}

The type theory that Gallina implements is CIC$_{\omega}$, or the Calculus of Inductive Constructions.
CIC$_{\omega}$ is based on the Calculus of Constructions (CoC), a variant of the lambda calculus with polymorphism (types that dependent on types) and dependent types (types that depend on terms)~\cite{coquand:inria-00076024}.
CoC with an infinite universe hierarchy is called CoC$_{\omega}$. % TODO need to explain or defer
The syntax for CoC$_{\omega}$ is in Figure~\ref{fig:coc-syntax}.

\begin{figure*}
\small
\begin{grammar}
<t> ::= ... | \hspace{0.06cm} Ind (<v> : <t>)\{<t>,\ldots,<t>\} \hspace{0.06cm} | \hspace{0.06cm} Constr (<i>, <t>) \hspace{0.06cm} | \hspace{0.06cm} Elim(<t>, <t>)\{<t>,\ldots,<t>\}
\end{grammar}
\vspace{-0.3cm}
\caption{CIC$_\omega$ is CoC$_\omega$ with inductive types, inductive constructors, and primitive eliminators.}
\label{fig:cic-syntax}
\end{figure*}

The syntax for CIC$_{\omega}$ is in Figure~\ref{fig:cic-syntax}), building on syntax from an existing paper~\cite{Timany2015FirstST}.
CIC$_{\omega}$ extends CoC$_{\omega}$ with inductive types~\cite{inductive}.
Inductive types are defined solely by their constructors (ways of constructing or making a term with that type)
and eliminators (ways of eliminating or inducting over a term with that type).

Consider the inductive type \lstinline{nat} of unary natural numbers:

\begin{lstlisting}
TODO nat in CIC$_{\omega}$
\end{lstlisting}
A unary natural number is either \lstinline{0} or the successor \lstinline{S} of another natural number;
these are the two constructors of \lstinline{nat}.
The eliminator this yields is the standard induction principle for natural numbers:

\begin{lstlisting}
TODO eliminator for the above
\end{lstlisting}
which states that a proposition about the natural numbers holds if it holds for \lstinline{0} in the base case and, in the inductive case,
assuming it holds for some \lstinline{n}, it also holds for the successor \lstinline{S n}.


\begin{figure}
\begin{lstlisting}
TODO
\end{lstlisting}
\caption{The \lstinline{list} datatype in CIC$_{\omega}$}
\label{fig:list-theory}
\end{figure}

The first datatype that we need to write our proof that the list zip function preserves its length is the \lstinline{list} datatype;
this is in Figure~\ref{fig:list-theory}, and is quite similar to \lstinline{nat}.
There are two differences: \lstinline{list} is polymorphic over some type \lstinline{T} (so we can have a list of natural numbers,
for example, written \lstinline{list nat}), and the second constructor adds a new element of the type \lstinline{T} to the front of the list.
Otherwise, \lstinline{list} also has two constructors, \lstinline{nil} and \lstinline{cons}, where \lstinline{nil} represents the empty list,
and \lstinline{cons} sticks a new element in front of any existing list.
The eliminator for \lstinline{list} is similarly similar to the eliminator for \lstinline{nat}:

\begin{lstlisting}
TODO eliminator for list in CIC$_{\omega}$
\end{lstlisting}

\begin{figure}
\begin{lstlisting}
TODO
\end{lstlisting}
\caption{The \lstinline{length} function for \lstinline{list} in CIC$_{\omega}$.}
\label{fig:length-theory}
\end{figure}

Once we have inductive types like \lstinline{nat} and \lstinline{list}, we can write functions and proofs about them, like the \lstinline{length} function (Figure~\ref{fig:length-theory}).
The \lstinline{length} of the empty list \lstinline{nil} is \lstinline{0}, and the length of any other list
is just the successor (\lstinline{S}) of the result of recursively calling \lstinline{length} on everything but the first element of the list.
% TODO frame this using induction instead

With those preliminaries out of the way, we can finally write the program we want to verify.

\begin{figure}
\begin{lstlisting}
TODO
\end{lstlisting}
\caption{The list \lstinline{zip} function in CIC${_\omega}$.}
\label{fig:zip-theory}
\end{figure}

\paragraph{Program}
We can write the \lstinline{zip} function (Figure~\ref{fig:zip-theory}) that we will soon prove preserves the lengths of the input lists.

\paragraph{Specification}
then the spec, choice of specs, note here.

\paragraph{Proof}
finally this.
how Coq checks this for the expected type.

\subsubsection{Implementation: Gallina}
\label{sec:gallina}

\begin{figure}
   \lstinputlisting[firstline=1, lastline=3]{often/listswap.tex}
\caption{The \lstinline{list} datatype in Coq, from the Coq standard library.}
\label{fig:list}
\end{figure}

List becomes this (Figure~\ref{fig:list}), maybe float side by side with CIC$_{\omega}$.

\begin{figure}
\begin{lstlisting}
Definition length (T : Type) : list T $\rightarrow$ nat := fix length l :=
  match l with
   | nil => O
   | _ :: l' => S (length l')
  end.
\end{lstlisting}
\caption{The \lstinline{length} function for \lstinline{list} in Coq, from the Coq standard library.}
\label{fig:length}
\end{figure}

So our length becomes this (Figure~\ref{fig:length}, maybe float side by side with CIC$_{\omega}$.
Once we have inductive types, we can write functions and proofs about them, like the \lstinline{length} function (Figure~\ref{fig:length}).
The \lstinline{length} of the empty list \lstinline{nil} is \lstinline{0}, and the length of any other list
is just the successor (\lstinline{S}) of the result of recursively calling \lstinline{length} on everything but the first element of the list.
Note we can also write this using eliminators (show), and in fact that reduces to pattern matching.
We assumed \kl{primitive eliminators} so what we do is preprocess and so on (explain).
We don't show that step in the rest of the paper.

\begin{figure}
\begin{lstlisting}
Definition zip {a} {b} : list a -> list b -> list (a * b)%type :=
  fix zip arg_0__ arg_1__
        := match arg_0__, arg_1__ with
           | nil, _bs => nil
           | _as, nil => nil
           | cons a as_, cons b bs => cons (pair a b) (zip as_ bs)
  end.
\end{lstlisting}
\caption{The list \lstinline{zip} function from an old version of hs-to-coq~\cite{TODO}, up to renaming (TODO just say everything is, and when you introduce foundations just before this use induction principles and briefly mention fix-to-elim).}
\label{fig:zip}
\end{figure}

And so on (Figure~\ref{fig:zip}, also side by side hopefully).

%TODO introduce lazily and use the knowledge package: https://ctan.org/pkg/knowledge
%
%Conventions in this thesis with proof terms, including using induction principles/eliminators instead of pattern matching, and assuming primitive.
%Infinite universe hierarchy---mostly can ignore in this thesis, though matters in implementation.


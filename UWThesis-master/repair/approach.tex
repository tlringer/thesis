\section{Approach}
\label{sec:pumpkin-approach}

In the example from Section~\ref{sec:patch-motivating}, the change in \lstinline{IZR} broke many proofs.
The example patch to a single proof (the proof of \lstinline{plus_negative_positive}) carried enough information (the rewrite by \lstinline{INR_IPR})
to fix the other broken proofs.
More generally, example-based proof repair takes advantage of the fact that an example patch to a broken proof can carry enough information to fix other proofs
broken by the same change.

\sysname implements a prototype of this.
To use \sysname (Section~\ref{sec:pumpkin-workflow}), the proof engineer modifies a single proof script to provide an \textit{example} of how to adapt a proof to a change.
\sysname extracts that information into a \textit{patch candidate}---a function that describes the change in the example patched proof,
but that is localized to the context of the example, and not yet enough to fix other proofs broken by the change.
\sysname then generalizes that candidate into a \textit{reusable patch}: a function
that can be used to fix other broken proofs broken by the same change, which \sysname defines as a Coq term.
In other words, looking back to the thesis statement, the information shows up in the difference between versions of the example patched proof.
\sysname can extract, generalize, and in some cases apply that information.

The \sysname prototype focuses on finding reusable patches to proofs in response to certain changes in the content of programs and specifications (Section~\ref{sec:pumpkin-scope}).
It does this using a combination of semantic differencing and proof term transformations:
Differencing (Section~\ref{sec:pumpkin-spec-diff} looks at the difference between versions of the example patched proof for this information, and finds the candidate.
Then, proof term transformations (Section~\ref{pumpkin-spec-trans}) modify that candidate to produce the reusable proof patch.
All of this happens over proof terms in Gallina, since tactics may hide necessary information as I will soon show.
\sysname has only preliminary support for proof script integration and patch application (see Section~\ref{sec:pumpkin-impl}),
though I will address this limitation with the \toolnamec extension in Chapter~\ref{chapt:pi}.

\subsection{Workflow: Repair by Example}
\label{sec:pumpkin-workflow}

The interface to \sysname is exposed to the proof engineer as a \textit{command}. % TODO use knowledge package, and maybe move back to Chapter 2
Commands in Coq are similar to tactics, except that they can occur outside of the context of proofs, and define new terms.
In this case, \sysname extends Coq with a new command called \lstinline{Patch Proof}, with the syntax:

\begin{lstlisting}
  Patch Proof old_proof new_proof as patch_name. 
\end{lstlisting}
where \lstinline{old_proof} and \lstinline{new_proof} are the old and new versions of the example patched proof,
and \lstinline{patch_name} is the desired name of the reusable proof patch.\footnote{Section~\ref{sec:pumpkin-impl} describes an alternative interface for \sysname with Git integration.}
This invokes the \sysname plugin, which searches for a reusable proof patch
and defines it as a new term if successful.
All terms that \sysname defines are type checked in the end, so \sysname does not extend the TCB. % TODO use the cool knowledge package here, since introduced a while ago 

\begin{figure}
%\begin{algorithm}
\begin{algorithmic}
\renewcommand{\thealgorithm}{}
\footnotesize
\caption{\footnotesize{find\_patch(old\_proof, new\_proof)}}
    \STATE \diff{\textit{diff} types of old\_proof and new\_proof for goals}
    \STATE \diff{\textit{diff} terms old\_proof and new\_proof for candidates}
    \IF{there are candidates}
      \STATE \diff{\textit{transform} candidates}
      \IFRETURN{there are patches}{patches}
    \ENDIF
    \RETURN failure
\end{algorithmic}
%\end{algorithm}
\caption{Search procedure for a reusable proof patch in \sysname.}
\label{alg:patching}	
\end{figure}

When the proof engineer calls \lstinline{Patch Proof}, this invokes the proof patch search procedure in Figure~\ref{alg:patching}.
The search procedure starts by differencing the \textit{types} of \lstinline{old_proof} and \lstinline{new_proof}
(that is, the theorems they prove).
The result that it finds is the \textit{goal type}: the type that the reusable proof patch should have.
It then differences the \textit{terms} \lstinline{old_proof} and \lstinline{new_proof} directly to identify candidate proof patches,
which are themselves proof terms.
Finally, it transforms those proof patches directly into a reusable patch.
If it finds a patch with the goal type, it succeeds and defines it.

\begin{figure*}
\begin{minipage}{0.50\textwidth}
\lstset{language=coq, aboveskip=0pt, belowskip=0pt}
\lstinputlisting[firstline=1, lastline=1]{repair/introex.tex}
\lstinputlisting[backgroundcolor=\color{orange!35},firstline=2,lastline=2]{repair/introex.tex}
\lstinputlisting[firstline=3, lastline=8]{repair/introex.tex}
\lstinputlisting[firstline=1, lastline=4]{repair/introexterm.tex}
\lstinputlisting[backgroundcolor=\color{orange!35},firstline=5,lastline=5]{repair/introexterm.tex}
\lstinputlisting[firstline=6, lastline=9]{repair/introexterm.tex}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
\lstset{language=coq, aboveskip=0pt, belowskip=0pt}
\lstinputlisting[firstline=9, lastline=9]{repair/introex.tex}
\lstinputlisting[backgroundcolor=\color{orange!35},firstline=10,lastline=10]{repair/introex.tex}
\lstinputlisting[firstline=11, lastline=16]{repair/introex.tex}
\lstinputlisting[firstline=11, lastline=14]{repair/introexterm.tex}
\lstinputlisting[backgroundcolor=\color{orange!35},firstline=15,lastline=15]{repair/introexterm.tex}
\lstinputlisting[firstline=16, lastline=19]{repair/introexterm.tex}
\end{minipage}
\caption{Two proofs with different conclusions (top) and the
corresponding proof terms (bottom) with relevant type information. We highlight the change in theorem conclusion and
the difference in terms that corresponds to a patch.}
\label{fig:example}
\end{figure*}

Consider, for example, the change from the theorem \lstinline{old} to the slightly stronger theorem \lstinline{new} in Figure~\ref{fig:example}.
Changing \lstinline{old} to \lstinline{new} can break proofs that used to successfully apply \lstinline{old}, so that a proof like this:

\begin{lstlisting}[language=coq]
Proof.
  $\ldots$
  (@\succeeds{apply old.}@)(@\vspace{-0.1cm}@)
  $\ldots$
Defined.
\end{lstlisting}
fails after migrating to \lstinline{new}:

\begin{lstlisting}[language=coq]
Proof.
  $\ldots$
  (@\fails{apply new.}@)(@\vspace{-0.1cm}@)
  $\ldots$
Defined.
\end{lstlisting}
When we call:

\begin{lstlisting}
Patch Proof old new as patch.
\end{lstlisting}
\sysname invokes the search procedure, which differences \lstinline{old} and \lstinline{new} to infer the goal type for the patch.
In this case, it infers the following goal:

\begin{lstlisting}[language=coq]
  (@\ltacforall@) n m p, n <= m $\rightarrow$ m <= p $\rightarrow$ (@\diff{n <= p}@) $\rightarrow$ (@\diff{n <= p + 1}@)
\end{lstlisting}
which takes us from the conclusion of \lstinline{new} back to the conclusion of \lstinline{old}.
It then differences the terms \lstinline{old} and \lstinline{new} to identify candidate proof patches (Section~\ref{sec:pumpkin-spec-diff}),
then tranforms those candidates to a reusable proof patch with that type (Section~\ref{sec:pumpkin-spec-trans}),
which it defines as a new constant \lstinline{patch}.
This is something that we can use to fix other proofs broken by this change, either by applying it with traditional proof automation:

\begin{lstlisting}[language=coq]
Proof.
  $\ldots$
  (@\diff{apply patch.}@) (@\succeeds{apply new.}@)
  $\ldots$
Defined.
\end{lstlisting}
or by using the automation in Section~\ref{sec:pumpkin-impl}.

\subsection{Scope: Changes in Content}
\label{sec:pumpkin-scope}

The search procedure in Figure~\ref{alg:patching} searches for patches to proofs broken by changes in the \textit{content} of programs and specifications.
For example, \sysname can support the change in Figure~\ref{fig:example}, since content (the conclusion of the theorem) changes,
but all else remains identical.
In general, the \sysname prototype does not support any changes that add, remove, or rearrange any hypotheses.
Chapter~\ref{chapt:pi} introduces an extension to \sysname that supports a broad class of
changes in datatypes that may change in those ways.

The search procedure can be configured to different classes of change in the content of programs and specifications.
Thus, before running the search procedure, \sysname infers a \textit{configuration} from the example change.
This configuration customizes the highlighted lines for an entire class of changes:
it determines what to diff on lines 1 and 2,
and what transformations to run to achieve what goal on line 4.

Figure~\ref{fig:example} used the configuration for a change in the conclusion of a theorem.
Given two such proofs:

%We describe one
%such procedure in this section; we descibe three more
%in Section~\ref{sec:case}.
\begin{lstlisting}[language=coq]
  (@\ltacforall@) x, H x $\rightarrow$ (@\diff{P}@) x(@\vspace{-0.1cm}@)
  (@\ltacforall@) x, H x $\rightarrow$ (@\diff{P'}@) x
\end{lstlisting}
\sysname searches for a patch with this goal type:

\begin{lstlisting}[language=coq]
  (@\ltacforall@) x, H x $\rightarrow$ (@\diff{P'}@) x $\rightarrow$ (@\diff{P}@) x
\end{lstlisting}

In total, the \sysname prototype currently implements six configurations.
Section~\ref{sec:pumpkin-impl-procedure} explains these configurations,
and Section~\ref{sec:pumpkin-results} describes real-world examples that demonstrate more configurations.

\subsection{Differencing: Candidates from Examples}
\label{sec:pumpkin-spec-diff}

Differencing operates over terms and types. Differencing tactics
would be insufficient, since tactics and hints may mask patches.
For example, for the change in Figure~\ref{fig:example},
the tactics are identical, even though the proof term changes.\footnote{Since this is a simple example, replaying an existing tactic happens to work. There
are additional examples in the repository (\lstinline{Cex.v}).} % TODO what? What did this even mean? lmao
Differencing instead looks at the change in terms to extract the patch candidates.

In the end, differencing identifies the semantic difference between the old and new versions of the proof terms for the example patched proof.
The semantic difference is the difference between two terms that corresponds to the difference between their types.
I will explain this more in Section~\ref{sec:pumpkin-diff}.

The details of the semantic difference and where differencing looks to find it vary by configuration.
Consider a simplified version of the example in Figure~\ref{fig:example}, using the configuration for changes in conclusions:

\begin{algorithm}
\footnotesize
\begin{algorithmic}[1]
%  Is it really necessary to say that an algorithm might do initialization?
%  \STATE Build trees for search
  %\STATE build trees for proofs
  %\REPEAT
    \STATE \textit{diff} \diff{theorem conclusions} of old\_proof and new\_proof for goals
    \STATE \textit{diff} \diff{function bodies} of old\_proof and new\_proof for candidates
    \STATE \textbf{if} there are candidates \textbf{then}
    \STATE \hspace*{1em} \textit{transform} candidates
\end{algorithmic}
\end{algorithm}
Rather than look at the entire example, let us look for now at just the base case (line 13):

\begin{lstlisting}[language=coq]
  old_proof := (@\diff{le\_plus\_trans n m 1}@) H : (@\diff{n <= m + 1}@)(@\vspace{-0.1cm}@)
  new_proof := H : (@\diff{n <= m}@)
\end{lstlisting}
The semantic differencing component first identifies the difference in their types (lines 11 and 12), here:

\begin{lstlisting}
  (@\diff{n <= m}@) $\rightarrow$ (@\diff{n <= m + 1}@)
\end{lstlisting}
This is the \textit{candidate} goal type.
It then finds a difference in terms that has that type (line 13):

\begin{lstlisting}[language=coq]
  fun (H : n <= m) => (@\diff{le\_plus\_trans n m 1}@) H
\end{lstlisting}
This is the \emph{candidate} for a reusable patch.
This candidate is close, but it is not yet a reusable patch. In particular, this candidate
maps base case to base case (it is applied to \lstinline{m}); the patch should map conclusion to conclusion (it should
be applied to \lstinline{p}).
This is where the proof term transformations will come in.

\paragraph{Summary}
In summary, differencing has the following specification:

% TODO may need to improve this, just want something here for now
\begin{itemize}
\item \textbf{Inputs}: \lstinline{old_proof}, \lstinline{new_proof}, a configuration \lstinline{config}, and a final goal type \lstinline{goal}, assuming:
\begin{itemize}
\item the change from \lstinline{old_proof} to \lstinline{new_proof} is in the class of changes supported by \lstinline{config}.
\end{itemize}
\item \textbf{Outputs}: a list of terms \lstinline{candidates} of patch candidates, and a candidate goal type \lstinline{candidate_goal}, guaranteeing:
\begin{itemize}
\item each term in \lstinline{candidates} has type \lstinline{candidate_goal}.
\end{itemize}
\end{itemize}
\sysname infers the configuration type and the final goal from the change itself, so the proof engineer does not have to provide this information.
\sysname could in theory infer the wrong configuration or the wrong goal type, but this would not sacrifice soundness---it would mean only that
the patch procedure would either fail to produce a patch, or produce a patch that is not useful in the end.
All terms that \sysname produces are well-typed. % TODO hyphen or no hyphen?

\subsection{Transformations: Patches from Candidates}
\label{sec:pumpkin-spec-trans}

Differencing produces patch candidates that are localized to a particular context according to the inferred goal for that change,
but does not yet generalize to other contexts.
The transformations are what take each candidate and tries to modify it to produce a term that \textit{does} generalize to other contexts.
If it succeeds, it has found a \textit{reusable patch}.

Consider once more the example in Figure~\ref{fig:example}.
The candidate patch that differencing found:

\begin{lstlisting}[language=coq]
  candidate := fun (H : n <= m) => (@\diff{le\_plus\_trans n m 1}@) H.
\end{lstlisting}
has this type:

\begin{lstlisting}
  candidate : (@\diff{n <= m}@) $\rightarrow$ (@\diff{n <= m + 1}@)
\end{lstlisting}
The reusable patch that \sysname is looking for, however, should have this type:

\begin{lstlisting}[language=coq]
  (@\ltacforall@) n m p, n <= m $\rightarrow$ m <= p $\rightarrow$ (@\diff{n <= p}@) $\rightarrow$ (@\diff{n <= p + 1}@)
\end{lstlisting}
as this is the goal that \sysname inferred for this configuration.
The transformations that \sysname runs will attempt to transform the candidate
into a patch with that type.

The details of which transformations to run vary by configuration.
There are four transformations that turn patch candidates into reusable proof patches:

\begin{enumerate}
\item \textit{patch specialization} to arguments,
\item \textit{patch generalization} of arguments or functions,
\item \textit{patch inversion} to reverse a patch, and
\item \textit{lemma factoring} to break a term into parts.
\end{enumerate}
Each configuration chooses among these transformations strategically based on the structure of the proof term.

For Figure~\ref{fig:example}, we can instantiate \textit{transform} in the configuration with two transformations:

\begin{algorithm}
\footnotesize
\begin{algorithmic}[1]
%  Is it really necessary to say that an algorithm might do initialization?
%  \STATE Build trees for search
  %\STATE build trees for proofs
  %\REPEAT
    \STATE \textit{diff} conclusions of the theorems of old\_proof and new\_proof for goals
    \STATE \textit{diff} bodies of the proof terms for candidates
    \STATE \textbf{if} there are candidates \textbf{then}
    \STATE \hspace*{1em} \diff{\textit{generalize} and then \textit{specialize}} candidates
\end{algorithmic}
\end{algorithm}
That is, first, \sysname \textit{generalizes} the candidate by \lstinline{m} (line 11), which lifts it out of the base case:

\begin{lstlisting}
  fun (@\diff{n0}@) n m p H0 H1 =>(@\vspace{-0.04cm}@)
    (fun (H : n <= (@\diff{n0}@)) => le_plus_trans n (@\diff{n0}@) 1 H)(@\vspace{-0.04cm}@)
  : (@\ltacforall@) (@\diff{n0}@) n m p,
      n <= m $\rightarrow$
      m <= p $\rightarrow$
      n <= (@\diff{n0}@) $\rightarrow$
      n <= (@\diff{n0}@) + 1.
\end{lstlisting}
\sysname then \textit{specializes} this generalized candidate to \lstinline{p} (line 16), the argument
to the conclusion of \lstinline{le_ind}. This produces a patch:

\begin{lstlisting}
  patch n m p H0 H1 := (@\vspace{-0.04cm}@)
    (fun (H : n <= (@\diff{p}@)) => le_plus_trans n (@\diff{p}@) 1 H)(@\vspace{-0.04cm}@)
  : (@\ltacforall@) n m p, n <= m $\rightarrow$ m <= p $\rightarrow$ n <= (@\diff{p}@) -> n <= (@\diff{p}@) + 1
\end{lstlisting}
which has the goal type.

This simple example uses only two transformations.
The other transformations help turn candidates into patches in similar ways, all guided by
the structure of the proof term.
I will describe these transformations more in Section~\ref{sec:pumpkin-trans},
and present real-world examples that demonstrate more configurations in Section~\ref{sec:pumpkin-results}.

\paragraph{Summary}
In summary, the transformations together have the following specification:

% TODO I hate this, should make it clearer, for both summaries so far
\begin{itemize}
\item \textbf{Inputs}: the inputs and outputs of differencing, assuming:
\begin{itemize}
\item the assumptions and guarantees from differencing hold.
\end{itemize}
\item \textbf{Outputs}: a term \lstinline{patch} that is the reusable proof patch, guaranteeing:
\begin{itemize}
\item \lstinline{patch} has the inferred final \lstinline{goal} type for the change.
\end{itemize}
\end{itemize}
When these transformations fail, or when the list of candidates that differencing returns is empty,
\sysname simply fails to return a patch.
As with differencing, it is possible that a mistake in the implementation of a given configuration
leads to a final \lstinline{goal} type is not useful to the proof engineer,
but this cannot soundness:
every \lstinline{patch} \toolname produces is well-typed.


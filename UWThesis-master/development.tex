\section{Proof Development}
\label{sec:mot-dev}

For the sake of this chapter, I will not demonstrate proof development, maintenance, and repair on a C compiler or on an OS microkernel.
Instead, I will start by demonstrating a simple proof development: 
that the list zip function preserves its length.
This is a toy example, but it is worth noting that large proof developments like compilers and microkernels
are often made up of many of these smaller examples built on top of each other.	

\begin{figure}
\begin{lstlisting}
Definition zip {a} {b} : list a -> list b -> list (a * b)%type :=
  fix zip arg_0__ arg_1__
        := match arg_0__, arg_1__ with
           | nil, _bs => nil
           | _as, nil => nil
           | cons a as_, cons b bs => cons (pair a b) (zip as_ bs)
  end.
\end{lstlisting}
\caption{The list \lstinline{zip} function from an old version of hs-to-coq~\cite{TODO}, up to renaming (TODO just say everything is, and when you introduce foundations just before this use induction principles and briefly mention fix-to-elim).}
\label{fig:zip}
\end{figure}

\paragraph{Program}
We can write the \lstinline{zip} function that we will soon prove preserves the lengths of the input lists.

\paragraph{Specification}
then the spec, choice of specs, note here.

\paragraph{Proof}
finally this, interactive process, automation, underlying proof term with highlighting to corresponding tactics,
how Coq checks this for the expected type.


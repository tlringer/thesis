\chapter{Conclusions \& Future Work}
\label{chapt:conclusions}

Through a combination of \kl{semantic differencing} and \kl{proof term transformations},
my \kl{proof repair} tool suite can extract, generalize, and apply the information that a change carries to fix proofs broken by the same change.
Proof repair can save and in fact already has saved work for proof engineers relative to reference manual repairs in practical use cases.
And so proof repair is \kl{reason to believe} that verifying a modified system should often, in practical use cases, be easier than verifying the original the first time around,
even when the proof engineer does not follow good development processes,
or when the change occurs outside of the proof engineer's control.

This sentiment was echoed recently in an article by an industrial proof engineer~\cite{article} (emphasis mine):

\begin{quote}
We have \textit{reason to think} such proof repair is tractable. Rather than trying to synthesize a complete proof from nothing---a problem known to be immensely difficult---we 
start from a correct proof of fairly similar software. We will be attempting proof reconstruction \textit{within a known neighborhood}.
\end{quote}
The proof engineer credited my proof repair work on social media, % TODO link to Twitter
but noted that there ought to be much more work in this space.

I agree, and I want to take that a step further:
I believe that we can build on proof repair to build the next era of proof engineering.
I believe that era will be one in which programmers of all skill levels across all domains can develop and maintain verified systems---an
era of \textit{proof engineering for all}.

\input{next}

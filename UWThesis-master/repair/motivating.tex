\section{Motivating Example}
\label{sec:patch-motivating}

% From PUMPKIN PATCH: Automation, Reimagined. Not changed, yet. Needs some work. Outstanding:
% 1. Can we link to code and show Patch Proof on this example?
% 2. User didn't fix all of the library functions, even; paper didn't mention that.
% 3. Reframe so less visionary?
% 4. Flow with thesis frame?
% TODO for real, get this working in vanilla pumpkin patch also

Traditional proof automation considers only the current state of programs, specifications, and proofs.
This is a missed opportunity: verified software systems are rarely static.
Like unverified systems, verified systems evolve over time.

With traditional proof automation, the burden of change largely falls on proof engineers.
Proof repair by example shows that this does not have to be true.
It is a form of proof automation that views programs, specifications, and proofs as fluid entities.
When a program or specification changes and this breaks many proofs,
it extracts information found in the difference between the old and new versions of a single patched proof,
and generalizes that to a \emph{reusable patch} that can fix other proofs broken by the same change.

\paragraph{Without Proof Repair} Experienced Coq proof engineers use design principles and custom tactics to make proofs
resilient to change. These techniques are useful for large proof developments, but they
place the burden of change on the proof engineer. This can be problematic
when change occurs outside of the proof engineers's control.

\begin{figure*}
\begin{minipage}{0.55\textwidth}
\centering
\lstset{language=coq, aboveskip=0pt, belowskip=0pt}
\lstinputlisting[firstline=1, lastline=3]{repair/izr.tex}
\lstinputlisting[backgroundcolor=\color{orange!35},firstline=4,lastline=5]{repair/izr.tex}
\lstinputlisting[firstline=6, lastline=6]{repair/izr.tex}
\end{minipage}
\hfill
\begin{minipage}{0.44\textwidth}
\centering
\lstset{language=coq, aboveskip=0pt, belowskip=0pt}
\lstinputlisting[firstline=8, lastline=10]{repair/izr.tex}
\lstinputlisting[backgroundcolor=\color{orange!35},firstline=11,lastline=12]{repair/izr.tex}
\lstinputlisting[firstline=13, lastline=13]{repair/izr.tex}
\end{minipage}
%\setlength{\belowcaptionskip}{-2pt}
\caption[Caption]{Old (left) and new (right) definitions of \lstinline{IZR} in Coq.
The old definition applies injection from naturals to reals and conversion of positives to
naturals; the new definition applies injection from positives to reals.}
\label{fig:izr}
\end{figure*}

Consider a commit from the Coq 8.7 release~\cite{coq87commit}. 
This commit redefined injection from integers to reals (Figure~\ref{fig:izr}).
This change broke 18 proofs in the standard library. 

The Coq developer who committed the change fixed the broken proofs, then
made an additional 12 commits to address the change in \lstinline{coq-contribs},
a regression suite of projects that the Coq developers maintain as versions change.
Many of these changes were simple. For example, the developer wrote a lemma that describes the change:

\lstset{language=coq, aboveskip=3pt, belowskip=3pt}
\begin{lstlisting}
  Lemma INR_IPR : (@\ltacforall@)p, INR (Pos.to_nat p) = IPR p.
\end{lstlisting}
The developer then used this lemma to fix broken proofs within the standard library. 
For example, one proof broke on this line:

\begin{lstlisting}
  (@\fails{rewrite Pos2Nat.inj\_sub by trivial.}@)
\end{lstlisting}
It succeeded with the lemma:

\begin{lstlisting}
  rewrite (@\diff{<- 3!INR\_IPR}@), (@\succeeds{Pos2Nat.inj\_sub by trivial.}@)
\end{lstlisting}

These changes are outside-facing: Coq users have to make similar changes to their own proofs when
they update from Coq 8.6 to Coq 8.7. The Coq developer can update some tactics to account for this, but it is 
impossible to account for every tactic that users could use.
Furthermore, while the developer responsible for the changes knows about
the lemma that describes the change, the Coq user does not. The Coq user must determine
how the definition has changed and how to address the change, perhaps by reading documentation or by
talking to the developers. 

\paragraph{With Proof Repair} When a proof engineer updates the Coq standard library, a proof repair tool can determine
that the definition has changed, then analyze changes in the standard library and in \lstinline{coq-contribs}
that resulted from the change in definition (in this case, rewriting by the lemma).
It can extract a reusable patch from those changes, which it can automatically apply within broken user proofs.
The proof engineer never has to consider how the definition has changed.


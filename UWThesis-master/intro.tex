\chapter{Introduction}

% Current intro sources, mixed together:
% - some new content
% - research statement
% - QED at Large (intro and why proof engineering matters)
% - PUMPKIN Pi
% TODO somewhere, clarify scope of verification here

% TODO can say ``see survey paper''

What would it take to empower programmers of all skill levels across all domains to formally prove
the absence of costly or dangerous bugs in software systems---that is, to formally \textit{verify} them?

Verification has already come a long way toward this since its inception.
This is especially true when it comes to the scale of systems that can be verified.
The seL4~\cite{Klein2009} verified operating system (OS) microkernel, for example,
is the effort of a team of proof engineers spanning more than
a million lines of proof, costing over 20 person-years.
Given a famous 1977 critique of verification~\cite{DeMillo1977} (emphasis mine):

\begin{quote}
\textit{A sufficiently fanatical researcher}
might be willing to devote \textit{two or 
three years} to verifying a significant 
piece of software if he could be 
assured that the software would remain stable.
\end{quote}
I could argue that, over 40 years, either verification has become easier,
or researchers have become more fanatical. Unfortunately, not all has changed (emphasis still mine):

\begin{quote}
But real-life programs need to 
be maintained and modified. 
There is \intro{no reason to believe} that verifying a modified program is any 
easier than verifying the original the 
first time around.
\end{quote}
This remains so difficult that sometimes, even experts give up in the face of change (Section~\ref{sec:irl}).

This thesis aims to change that by taking advantage of a missed opportunity: tools for developing verified systems
have no understanding of how these systems evolve over time, so they miss out on crucial information.
This thesis introduces a new class of verification tools called \textit{proof repair} tools.
Proof repair tools understand how software systems evolve, and use the crucial information that evolution carries
to automatically evolve proofs about those systems.
This gives us \kl{reason to believe}.

\section{Thesis}

% TODO segue sentence
Proof repair falls under the umbrella of \textit{proof engineering}: the technologies that make it easier
to develop and maintain verified systems.
Much like software engineering scales programming to large systems, so proof engineering scales verification to large systems. 
In recent years, proof engineers have verified OS microkernels~\cite{Klein2009, Klein2014micro}, machine learning systems~\cite{pmlr-v70-selsam17a}, distributed systems~\cite{TODO}, constraint solvers~\cite{TODO}, web browser kernels~\cite{TODO}, compilers~\cite{Leroy:POPL06, Leroy2009}, file systems~\cite{TODO}, and even a quantum optimizer~\cite{TODO}.
Practitioners have found these verified systems to be more robust and secure in deployment (Chapter~\ref{chapt:mot}). % TODO cite section
% TODO maybe include the Why Proof Engineering Matters from QED at Large in Chapter 2 somewhere. Maybe move this too.

Proof engineering focuses in particular on verified systems that have been
developed using special tools called \textit{proof assistants}.
Examples of proof assistants include Coq~\cite{coq}, Isabelle/HOL~\cite{isabelle}, 
HOL Light~\cite{hollight}, and Lean~\cite{lean}.
The proof assistant that I focus on in this thesis will be the Coq proof assistant.
A discussion of how this work carries over to other proof assistants is in Chapter~\ref{chapt:conclusions}.

To develop a verified system using a proof assistant like Coq, the proof engineer does three things:

\begin{enumerate}
\item implements a program using a functional programming language,
\item specifies what it means for the program to be correct, and
\item proves that the program satisfies the specification.
\end{enumerate}
This proof assistant then automatically checks this proof with a small trusted part of its system~\cite{Barendregt2002,Barendregt2351}.
If the proof is correct, then the program satisfies its specification---it is \textit{verified}.

Proof repair automatically fixes broken proofs in response to changes in programs and specifications.
For example, a proof engineer who optimizes an algorithm may change the program, but not the specification; a proof engineer who adapts an OS to new hardware may change both. Even a small change to a program or specification can break many proofs, especially in large systems.
Changing a verified library, for example, can break proofs about programs that depend on that library---and those breaking changes
can be outside of the proof engineers' control.

Proof repair views these broken proofs as bugs that a tool can patch.
In doing so, it shows that there \textit{is} reason to believe that verifying a modified system should often, in practical use cases, be easier than verifying the original the first time around,
even when proof engineers do not follow good development processes,
or when change occurs outside of proof engineers' control.
More formally:

\begin{quote}
\textbf{Thesis}: Changes in programs, specifications, and proofs carry information that a tool can extract, generalize, and apply to fix other proofs broken by the same change in practical use cases. A tool that automates this can save work for proof engineers relative to reference manual repairs.
\end{quote}

\section{Approach}

\begin{figure}
\caption{TODO}
\label{fig:workflow}
\end{figure}

% TODO here, say: we assume Coq in here, see survey paper for more, tactics versus no tactics, de bruijn, where Coq is,
% many ideas generalize but eh, doesn't adapt exactly as-is.
% then expand on that in related work or conclusion

% TODO the amount of background: in reading guide, give resources for learning Coq in more detail, but don't go into too much Coq detail here

The way that proof engineers typically write proofs can obfuscate the information that changes in programs, specifications, and proofs carry.
The typical proof engineering workflow in Coq is interactive: The proof engineer passes Coq high-level
search procedures called \textit{tactics} (like \lstinline{induction}), and Coq responds to each tactic
by refining the current goal to some subgoal (like the proof obligation for the base case). This loop of tactics and goals 
continues until no goals remain, at which point the proof engineer has constructed a high-level sequence of tactics called a \textit{proof script}.
To check the proof, the proof assistant compiles it down to a low-level representation called a \textit{proof term},
then checks that the proof term has the expected type.
Figure~\ref{fig:workflow} illustrates this workflow.

The high-level language of tactics can abstract away important details that a proof repair tool needs,
but the low-level language of proof terms can be brittle and challenging to work with.
Crucially, though, the low-level language comes with lots of structure and strong guarantees.
My approach to proof repair works in the low-level language to take advantage of that.
It then builds back up to the high-level language in the end.

By working at the low-level language, it is able to systematically and with strong guarantees extract and generalize the 
information that breaking changes carry,
then apply those changes to fix other proofs broken by the same change.
But by later building up to the high-level language,
it can in the end produce proofs that integrate more naturally with proof engineering workflows.

This works using a combination of semantic differencing and program transformations in this low-level language.
In particular, it uses a semantic differencing algorithm to extract information from a breaking change in a program, specification, or proof.
It then combines that with program transformations to generalize and, in some cases, apply that information to fix other 
proofs broken by the same change.
In the end, it uses a prototype decompiler to get from the low-level language back up to the high-level language,
so that proof engineers can continue to work in that language going forward. % TODO lol this sucks but whatever it's a first draft

\section{Results}

The technical results of this thesis are threefold:

\begin{enumerate}
\item the \textbf{design} of differencing algorithms \& program transformations for proof repair, 
\item an \textbf{implementation} of a proof repair tool suite, and
\item \textbf{case studies} to evaluate the tool suite on real proof repair scenarios.
\end{enumerate}
Viewing the thesis statement as a theorem, the proof is as follows: % TODO link to particular sections here

\begin{quote}
\textbf{Thesis Proof}: Changes in programs, specifications, and proofs carry information that a tool can extract, generalize, and apply to fix other proofs broken by the same change (by \textbf{design} and \textbf{implementation}). A tool that automates this can save work for proof engineers relative to reference manual repairs in practical use cases (by \textbf{case studies}).
\end{quote}

\paragraph{Design}
The design describes semantic differencing algorithms to extract information from breaking changes in verified systems,
along with proof term transformations to generalize and, in some cases, apply the information to fix proofs broken by the change. % TODO redundant but shitty first draft text so whatever
The semantic differencing algorithms compare the old and new versions of a changed term or type,
and from that find a diff that describes that information corresponding to that change;
the transformations then use that diff to transform some term to a more general fix.
The details vary by the class of change supported.
These design is guided heavily by foundational developments in depenedent type theory;
the theory is sprinkle throughout as appropriate. % TODO may want to list or link to sections here
More details including limitations are in the corresponding chapters. % TODO link to those chapters

\paragraph{Implementation}
The implementation shows that in fact \textit{a tool} can extract and generalize the information that changes carry,
and then apply that information to fix other proofs broken by the same change.
This implementation comes in the form of a proof repair tool suite for Coq called \sysnamelong (Proof Updater Mechanically Passing Knowledge Into New Proofs, Assisting the Coq Hacker).
\sysnamelong implements two kinds of proof repair: proof repair by example (Chapter~\ref{ch:example}) % TODO implementation chapters instead
and proof repair across type equivalences (Chapter~\ref{chapt:pi}). % 8.9.1 
Notably, since all repairs that \sysnamelong produces are checked Coq in the end, \sysnamelong does not extend \textit{Trusted Computing Base} (TCB):
the set of unverified components that the correctnes of the proof development depends on~\cite{TODO}. % TODO not just cite by also make this way less shitty of a definition
In total, \sysnamelong is about 15000 lines of code implemented in OCaml.
These 15000 lines of code consist of three plugins and a library,
which together bridge the gap between the theory supported by design and the practical proof repair needed for the case studies.
Toward that end, five notable features include:

\begin{enumerate}
\item a preprocessing tool to support features in the implementation language missing from the theory,
\item a prototype decompiler from proof terms to proof scripts for better workflow integration,
\item optimizations for efficiency,
\item meaningful error messages for usability, and
\item additional automation for applying patches. 
\end{enumerate}
More details and other features are in the corresponding chapters. % TODO link to those chapters

\paragraph{Case Studies}
The case studies show that \sysnamelong can save work for proof engineers relative to 
reference manual repairs in practical use cases. % TODO link to corresponding chapters instead
In particular, the case studies in Chapter~\ref{ch:example} show retroactively that a prototype implementation of proof repair
by example could have saved work for proof engineers on major proof developments.
The case studies in Chapter~\ref{chapt:pi} show that proof repair across type equivalences can save
and in fact has already saved work for proof engineers in practical use cases.

\input{guide}

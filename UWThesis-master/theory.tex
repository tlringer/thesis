\subsection{The Theory Beneath}
\label{sec:mot-theory}

Now that we have written a small proof development in Coq, let us take a step back and look at the theoretical foundations that make this possible.
While proof scripts help humans write proofs, it is thanks to the proof terms these compile down to that Coq is able to check our proof in the end.
These proof terms are in a rich functional programming language called \kl{Gallina} (Section~\ref{sec:gallina}).
Gallina implements a rich type theory called the \intro{Calculus of Inductive Constructions} (Section~\ref{sec:cic}).
This rich type theory makes it possible to write programs, specifications, and proofs in Coq,
and have a small part of Coq check those proofs in the end.

\subsubsection{Gallina}
\label{sec:gallina}

Gallina is a rich functional programming language with support for writing proofs.
To see the power of Gallina, let us dissect our proof that \lstinline{zip} preserves its length.
I mentioned earlier that the \lstinline{nat} and \lstinline{list} datatypes,
and the \lstinline{length} function itself, can all be found inside of the Coq standard library.
But looking into these datatypes and this function already points to many useful features of Gallina.

\begin{figure}
\begin{minipage}{0.30\textwidth}
\begin{lstlisting}
Inductive nat :=
| O : nat
| S : nat $\rightarrow$ nat.
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.68\textwidth}
\begin{lstlisting}
nat_rect :
  $\forall$ (P : nat $\rightarrow$ Type),
    P O $\rightarrow$ (* base case *)
    ($\forall$ (n : nat),
      (* inductive case *)
      P n $\rightarrow$ P (S n)) $\rightarrow$
    $\forall$ (n : nat), P n.
\end{lstlisting}
\end{minipage}
\caption{The type of natural numbers \lstinline{nat} in Coq defined inductively by its two constructors (left), and the type of the corresponding eliminator or induction principle \lstinline{nat_rect} that Coq generates (right).}
\label{fig:nat}
\end{figure}

Each of \lstinline{nat} and \lstinline{list} in Gallina is an \textit{inductive type}:
it is defined by its \textit{constructors} (ways of constructing a term with that type).
A \lstinline{nat} (Figure~\ref{fig:nat}, left), for example,
is either \lstinline{0} or the successor \lstinline{S} of another \lstinline{nat};
these are the two constructors of \lstinline{nat}.

Every inductive type in Gallina comes equipped with an \textit{eliminator} or induction principle
that the proof engineer can use to write functions and proofs about the datatype.
For example, the eliminator for \lstinline{nat} (Figure~\ref{fig:nat}, right) is the standard induction principle for natural numbers,
which Coq calls \lstinline{nat_rect}. % TODO footnote about nat_ind, nat_rec, nat_rect
This eliminator states that a statement \lstinline{P} (called the inductive \textit{motive}) about the natural numbers
holds for every number if it holds for \lstinline{O} in the base case and, in the inductive case,
assuming it holds for some \lstinline{n}, it also holds for the successor \lstinline{S n}.

\begin{figure}
\begin{minipage}{0.44\textwidth}
\begin{lstlisting}
Inductive list {T : Type} :=
| nil : list T
| cons :
    T $\rightarrow$ list T $\rightarrow$ list T.
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.54\textwidth}
\begin{lstlisting}
list_rect :
  $\forall$ {T : Type} (P : list T $\rightarrow$ Type),
    P nil $\rightarrow$ (* base case *)
    ($\forall$ (t : T) (tl : list T),
      (* inductive case *)
      P tl $\rightarrow$ P (cons t tl)) $\rightarrow$
    $\forall$ (l : list T), P l.
\end{lstlisting}
\end{minipage}
\caption{The type of polymorphic lists \lstinline{list} in Coq defined inductively by its two constructors (left), and the type of the corresponding eliminator or induction principle \lstinline{list_rect} that Coq generates (right). The curly brace notation means that the type parameter \lstinline{T} is implicit in applications.}
\label{fig:list}
\end{figure}

 % TODO footnote about nat_ind, nat_rec, nat_rect

A \lstinline{list} (Figure~\ref{fig:list}, left) is similar to a \lstinline{nat}, 
but with two differences: \lstinline{list} is polymorphic over some type \lstinline{T} (so we can have a list of natural numbers,
for example, written \lstinline{list nat}), and the second constructor adds a new element of the type \lstinline{T} to the front of the list.
Otherwise, \lstinline{list} also has two constructors, \lstinline{nil} and \lstinline{cons}, where \lstinline{nil} represents the empty list,
and \lstinline{cons} sticks a new element in front of any existing list.
Similarly, the eliminator for \lstinline{list} (Figure~\ref{fig:list}, right) looks like the eliminator for \lstinline{nat} 
but with an argument corresponding to the parameter \lstinline{T} over which \lstinline{list} is polymorphic,
and with an additional argument corresponding to the new element in the inductive case.

One interesting thing about the types of these eliminators \lstinline{list_rect} and \lstinline{nat_rect}
include universal quantification over all inputs, written $\forall$.
Gallina's type system is expressive enough to include universal quantification over inputs, as we will soon see.

\begin{figure}
\begin{minipage}{0.42\textwidth}
\begin{lstlisting}
Fixpoint length {T} l :=
  match l with
  | nil => O
  | cons t tl =>
      S (length tl)
  end.
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.54\textwidth}
\begin{lstlisting}
Definition length {T} l :=
  list_rect T (fun _ => nat)
    O
    (fun t tl (length_tl : nat) =>
      S length_tl)
    l.
\end{lstlisting}
\end{minipage}
\caption{The list \lstinline{length} function, defined both by pattern matching and recursion (left) and using the eliminator \lstinline{list_rect} (right).}
\label{fig:length}
\end{figure}

We can use these eliminators to write functions and proofs, like the \lstinline{length} function (Figure~\ref{fig:length}, right).
More standard is to write functions using pattern matching and guarded recursion, like the \lstinline{length} function from the Coq standard library (Figure~\ref{fig:length}, left).
Both of these two functions behave the same way, but the function on the left is perhaps a bit easier to understand from a traditional programming background:
the \lstinline{length} of the empty list \lstinline{nil} is \lstinline{0}, and the length of any other list
is just the successor (\lstinline{S}) of the result of recursively calling \lstinline{length} on everything but the first element of the list.
Indeed, \lstinline{list_rect}---like all eliminators in Coq---is just a constant that refers to a function itself defined using pattern matching and guarded recursion.
In fact, eliminators are equally expressive to pattern matching and guarded recursion~\cite{TODO}. % the general translation is hard and Coq sucks at eliminator gen though

\begin{figure}
\begin{lstlisting}
zip {T$_1$} {T$_2$} (l$_1$ : list T$_1$) (l$_2$ : list T$_2$) : list (T$_1$ * T$_2$) :=
  list_rect (fun _ : list T$_1$ => list T$_2$ $\rightarrow$ list (T$_1$ * T$_2$))
    (fun _ => nil)
    (fun t$_1$ tl$_1$ (zip_tl$_1$ : list T$_2$ $\rightarrow$ list (T$_1$ * T$_2$)) l$_2$ =>
      list_rect (fun _ : list T$_2$ => list (T$_1$ * T$_2$))
        nil
        (fun t$_2$ tl$_2$ (_ : list (T$_1$ * T$_2$)) =>
          cons (t$_1$, t$_2$) (zip_tl$_1$ tl$_2$))
        l$_2$)
    l$_1$
    l$_2$.
\end{lstlisting}
\caption{The list \lstinline{zip} function, taken from an existing tool~\cite{TODO} % TODO hs-to-coq cite
and translated to use eliminators.}
\label{fig:zip-elim}
\end{figure}

For the sake of this thesis, however, I will assume \intro{primitive eliminators}: eliminators that are a part of the core syntax and theory itself,
and that do not reduce to terms that use pattern matching and guarded recursion.
Likewise, when I show Gallina code, from this point forward, I will favor functions that apply eliminators rather than pattern matching, like the \lstinline{length} function from Figure~\ref{fig:length}
on the right.
%I remove the \lstinline{Definition} and \lstinline{Fixpoint} keywords, since everything from here on out is a \lstinline{Definition}.

To handle practical code that uses pattern matching and guarded recursion,
I preprocesss the code using a tool by my coauthor Nate Yazdani (more about this later). % TODO make this more formal, can say limitations, can say generates length above, wahtever
Figure~\ref{fig:zip-elim}, for example, shows the \lstinline{zip} function after running this tool.
In the rest of the paper, I skip this preprocessing step in examples, but I describe it more in the implementation section later.

With that in mind, we can now look back at the proof script and corresponding proof term in Figure~\ref{fig:zip-proof}.
There is a correpsondence between the proof script and the proof term, highlighted in the same color:
The proof term is a function from the context to a body that proves the goal type.
Every call to \lstinline{induction} in the proof script shows up as an application of the \lstinline{list} eliminator 
\lstinline{list_rect}, with the cases corresponding to the appropriate arguments of the eliminator.
The first call to \lstinline{auto} compiles down to \lstinline{eq_refl}, the constructor for the inductive equality type.
The second call to \lstinline{auto} compiles down to \lstinline{eq_sym}, the proof of symmetry of equality in the Coq standard library. % TODO not using absurd then?
Rewrites compile down to applications of an eliminator over the inductive equality type called \lstinline{eq_ind_r}.

Still, the proof terms can be difficult for a proof engineer to write and understand.
In Section~\ref{TODO}, I will introduce a prototype decompiler from proof terms back up to proof scripts
that makes it possible for \sysnamelong to work over highly structured \kl{Gallina} terms,
but produce proof scripts that the proof engineer can use going forward.

\subsubsection{Calculus of Inductive Constructions}
\label{sec:cic}

\begin{figure*}
\small
\begin{grammar}
<i> $\in \mathbbm{N}$, <v> $\in$ Vars, <s> $\in$ \{ Prop, Set, Type<i> \}

<t> ::= <v> \hspace{0.06cm} | \hspace{0.06cm} <s> \hspace{0.06cm} | \hspace{0.06cm} $\Pi$ (<v> : <t>) . <t> \hspace{0.06cm} | \hspace{0.06cm} $\lambda$ (<v> : <t>) . <t> \hspace{0.06cm} | \hspace{0.06cm} <t> <t>
\end{grammar}
\vspace{-0.3cm}
\caption{Syntax for CoC$_\omega$ with (from left to right) variables, sorts, dependent types, functions, and application.}
\label{fig:coc-syntax}
\end{figure*}

The type theory that Gallina implements is \intro{CIC$_{\omega}$}, or the \kl{Calculus of Inductive Constructions}.
CIC$_{\omega}$ is based on the Calculus of Constructions (CoC), a variant of the lambda calculus with polymorphism (types that dependent on types) and dependent types (types that depend on terms)~\cite{coquand:inria-00076024}.
CoC with an infinite universe hierarchy is called CoC$_{\omega}$. % TODO need to explain or defer
The syntax for CoC$_{\omega}$ is in Figure~\ref{fig:coc-syntax}.
Note that whereas in Gallina we represent universal quantification over terms or types with $\forall$, here we represent it with $\Pi$, as is standard.

\begin{figure*}
\small
\begin{grammar}
<t> ::= ... | \hspace{0.06cm} Ind (<v> : <t>)\{<t>,\ldots,<t>\} \hspace{0.06cm} | \hspace{0.06cm} Constr (<i>, <t>) \hspace{0.06cm} | \hspace{0.06cm} Elim(<t>, <t>)\{<t>,\ldots,<t>\}
\end{grammar}
\vspace{-0.3cm}
\caption{CIC$_\omega$ is CoC$_\omega$ with inductive types, inductive constructors, and \kl{primitive eliminators}.}
\label{fig:cic-syntax}
\end{figure*}

The syntax for CIC$_{\omega}$ is in Figure~\ref{fig:cic-syntax}), building on syntax from an existing paper~\cite{Timany2015FirstST};
the typing rules are standard and omitted. % TODO
CIC$_{\omega}$ extends CoC$_{\omega}$ with inductive types~\cite{inductive}.
As in Gallina, inductive types are defined by their constructors and eliminators.
Consider the inductive type \lstinline{nat} of unary natural numbers that we saw in Figure~\ref{fig:nat},
this time in CIC$_{\omega}$: % TODO explain sorts

\begin{lstlisting}
Ind (nat : Set) {
  nat,
  nat $\rightarrow$ nat
}
\end{lstlisting}
where the \lstinline{O} constructor type is the zeroth element in the list, and the \lstinline{S} constructor type is the first element.
Accordingly, the terms:

\begin{lstlisting}
Constr (O, nat)
\end{lstlisting}
and:

\begin{lstlisting}
Constr (1, nat)
\end{lstlisting}
refer to the constructors \lstinline{O} and \lstinline{S}, respectively.

As in Gallina, \lstinline{nat} comes associated with an eliminator.
Unlike in Gallina, here we truly assume \kl{primitive eliminators}---that these eliminators
do not reduce at all.
Instead, we represent them explicitly with the \lstinline{Elim} construct.
Thus, to eliminate over a natural number \lstinline{n} with motive \lstinline{P},
we write: % TODO check

\begin{lstlisting}
Elim (n, P) {
  f$_O$,
  f$_S$
}
\end{lstlisting}
where functions:

\begin{lstlisting}
f$_O$ : P O
\end{lstlisting}
and:

\begin{lstlisting}
f$_S$ : $\Pi$ (n : nat) . $\Pi$ (IHn : P n) . P (S n)
\end{lstlisting}
prove the base and inductive cases, respectively.
When \lstinline{n}, \lstinline{P}, \lstinline{f}$_O$, and \lstinline{f}$_S$ are arbitrary,
this statement has the same type as \lstinline{nat_rect} in Gallina.

Gallina implements CIC$_{\omega}$, but with a few important differences.
More information is on the website, % https://coq.github.io/doc/v8.9/refman/language/gallina-specification-language.html, noting it's 8.9
but two differences are relevant to repair:
The first is that Gallina lacks \kl{primitive eliminators}, as we mentioned earlier.
The second notable difference is that Gallina has constants that define terms---later on, this will help with building optimizations for repair tools.

Otherwise, a proof repair tool for Gallina can harness the power of CIC$_{\omega}$. This type theory is fairly simple,
but $\Pi$ makes it possible to quantify over both terms and types,
so that we can state powerful theorems and prove that they hold.
Inductive types make it possible to write proofs by induction.
Both of these constructs mean that terms in Gallina are extremely structured,
and as we will soon see, that structure makes a proof repair tool's job much easier.

But this structure can be difficult for proof engineers to work with,
which is why proof engineers typically rely on the tactics we saw in Section~\ref{sec:mot-workflow}.
Tactics more generally are a form of \textit{proof automation}, and this proof automation makes it much
simpler to develop proofs to begin with.
But it turns out this proof automation is a bit naive when it comes to \textit{maintaining} proofs
as programs and specifications change over time.
Proof repair is a new form of proof automation for maintaining proofs: it uses the rich type information carried by proof terms
to automatically fix broken proofs in response to change.

\iffalse
% TODO work in missing conventions somewhere
\mysubsubsec{Conventions}
All terms that we introduce in this section are in the Calculus of Inductive Constructions (CIC$_{\omega}$), the type theory
that Coq's proof term language Gallina implements.
CIC$_{\omega}$ is based on the Calculus of Constructions (CoC), a variant of the lambda calculus with polymorphism (types that depend on types) and dependent types (types that depend on terms)~\cite{coquand:inria-00076024}. CIC$_{\omega}$ extends CoC with
inductive types~\cite{inductive}.
Inductive types are defined solely by their constructors (like \lstinline{nil} and \lstinline{cons} for \lstinline{list}) and eliminators (like the induction principle for \lstinline{list}); this section assumes that these eliminators are primitive.

The syntax for CIC$_{\omega}$ with primitive eliminators is in Figure~\ref{fig:syntax}.
The typing rules are standard.
We assume inductive types $\Sigma$ with constructor $\exists$ and projections $\pi_l$ and $\pi_r$,
and an equality type \lstinline{=} with constructor \lstinline{eq_refl}.
We use $\vec{t}$ and $\{t_1, \ldots, t_n\}$ to denote lists of terms.
\fi



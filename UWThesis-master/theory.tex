\subsection{The Theory Beneath}
\label{sec:mot-theory}

(Needs readjustment to new frame.)
Our proof that the list zip function preserves its length uses \lstinline{nat} and \lstinline{list}
datatypes from the standard library, as well as a \lstinline{length} function..
All of these can be found in the Coq standard library.

\begin{figure}
\begin{minipage}{0.30\textwidth}
\begin{lstlisting}
Inductive nat :=
| O : nat
| S : nat $\rightarrow$ nat.
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.68\textwidth}
\begin{lstlisting}
nat_rect :
  $\forall$ (P : nat $\rightarrow$ Type),
    P O $\rightarrow$ (* base case *)
    ($\forall$ (n : nat),
      (* inductive case *)
      P n $\rightarrow$ P (S n)) $\rightarrow$
    $\forall$ (n : nat), P n.
\end{lstlisting}
\end{minipage}
\caption{The type of natural numbers \lstinline{nat} in Coq defined inductively by its two constructors (left), and the type of the corresponding eliminator or induction principle \lstinline{nat_rect} that Coq generates (right).}
\label{fig:nat}
\end{figure}

Each of \lstinline{nat} and \lstinline{list} in Gallina is an \textit{inductive type}:
it is defined by its \textit{constructors} (ways of constructing a term with that type).
A \lstinline{nat} (Figure~\ref{fig:nat}, left), for example,
is either \lstinline{0} or the successor \lstinline{S} of another \lstinline{nat};
these are the two constructors of \lstinline{nat}.

Every inductive type in Gallina comes equipped with an \textit{eliminator} or induction principle
that the proof engineer can use to write functions and proofs about the datatype.
For example, the eliminator for \lstinline{nat} (Figure~\ref{fig:nat}, right) is the standard induction principle for natural numbers,
which Coq calls \lstinline{nat_rect}. % TODO footnote about nat_ind, nat_rec, nat_rect
This eliminator states that a statement \lstinline{P} (called the inductive \textit{motive}) about the natural numbers
holds for every number if it holds for \lstinline{O} in the base case and, in the inductive case,
assuming it holds for some \lstinline{n}, it also holds for the successor \lstinline{S n}.

\begin{figure}
\begin{minipage}{0.44\textwidth}
\begin{lstlisting}
Inductive list {T : Type} :=
| nil : list T
| cons :
    T $\rightarrow$ list T $\rightarrow$ list T.
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.54\textwidth}
\begin{lstlisting}
list_rect :
  $\forall$ {T : Type} (P : list T $\rightarrow$ Type),
    P nil $\rightarrow$ (* base case *)
    ($\forall$ (t : T) (tl : list T),
      (* inductive case *)
      P tl $\rightarrow$ P (cons t tl)) $\rightarrow$
    $\forall$ (l : list T), P l.
\end{lstlisting}
\end{minipage}
\caption{The type of polymorphic lists \lstinline{list} in Coq defined inductively by its two constructors (left), and the type of the corresponding eliminator or induction principle \lstinline{list_rect} that Coq generates (right). The curly brace notation means that the type parameter \lstinline{T} is implicit in applications.}
\label{fig:list}
\end{figure}

 % TODO footnote about nat_ind, nat_rec, nat_rect

A \lstinline{list} (Figure~\ref{fig:list}, left) is similar to a \lstinline{nat}, 
but with two differences: \lstinline{list} is polymorphic over some type \lstinline{T} (so we can have a list of natural numbers,
for example, written \lstinline{list nat}), and the second constructor adds a new element of the type \lstinline{T} to the front of the list.
Otherwise, \lstinline{list} also has two constructors, \lstinline{nil} and \lstinline{cons}, where \lstinline{nil} represents the empty list,
and \lstinline{cons} sticks a new element in front of any existing list.
Similarly, the eliminator for \lstinline{list} (Figure~\ref{fig:list}, right) looks like the eliminator for \lstinline{nat} 
but with an argument corresponding to the parameter \lstinline{T} over which \lstinline{list} is polymorphic,
and with an additional argument corresponding to the new element in the inductive case.

One interesting thing about the types of these eliminators \lstinline{list_rect} and \lstinline{nat_rect}
include universal quantification over all inputs, written $\forall$.
Gallina's type system is expressive enough to include universal quantification over inputs---I will explain how
in Section~\ref{sec:mot-theory}.

\begin{figure}
\begin{minipage}{0.42\textwidth}
\begin{lstlisting}
Fixpoint length {T} l :=
  match l with
  | nil => O
  | cons t tl =>
      S (length tl)
  end.
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.54\textwidth}
\begin{lstlisting}
Definition length {T} l :=
  list_rect T (fun _ => nat)
    O
    (fun t tl (length_tl : nat) =>
      S length_tl)
    l.
\end{lstlisting}
\end{minipage}
\caption{The list \lstinline{length} function, defined both by pattern matching and recursion (left) and using the eliminator \lstinline{list_rect} (right).}
\label{fig:length}
\end{figure}

We can use these eliminators to write functions and proofs, like the \lstinline{length} function we will need for our proof development (Figure~\ref{fig:length}, right).
More standard is to write functions using pattern matching and guarded recursion, like the \lstinline{length} function from the Coq standard library (Figure~\ref{fig:length}, left).
Both of these two functions behave the same way, but the function on the left is perhaps a bit easier to understand from a traditional programming background:
the \lstinline{length} of the empty list \lstinline{nil} is \lstinline{0}, and the length of any other list
is just the successor (\lstinline{S}) of the result of recursively calling \lstinline{length} on everything but the first element of the list.
Indeed, \lstinline{list_rect}---like all eliminators in Coq---is just a constant that refers to a function itself defined using pattern matching and guarded recursion.
In fact, eliminators are equally expressive to pattern matching and guarded recursion~\cite{TODO}. % the general translation is hard and Coq sucks at eliminator gen though

For the sake of this thesis, however, I will assume \intro{primitive eliminators}: eliminators that are a part of the core syntax and theory itself,
and that do not reduce to terms that use pattern matching and guarded recursion.
Likewise, when I show Gallina code, I will always use functions that apply eliminators rather than pattern matching, like the \lstinline{length} function from Figure~\ref{fig:length}
on the right.
I remove the \lstinline{Definition} and \lstinline{Fixpoint} keywords, since everything from here on out is a \lstinline{Definition}.
To handle practical code that uses pattern matching and guarded recursion,
I preprocesss the code using a tool by my coauthor Nate Yazdani (more about this later). % TODO make this more formal, can say limitations, can say generates length above, wahtever
In the rest of the paper, I skip this preprocessing step in examples, but I describe it more in the implementation section later.


\begin{figure*}
\small
\begin{grammar}
<i> $\in \mathbbm{N}$, <v> $\in$ Vars, <s> $\in$ \{ Prop, Set, Type<i> \}

<t> ::= <v> \hspace{0.06cm} | \hspace{0.06cm} <s> \hspace{0.06cm} | \hspace{0.06cm} $\Pi$ (<v> : <t>) . <t> \hspace{0.06cm} | \hspace{0.06cm} $\lambda$ (<v> : <t>) . <t> \hspace{0.06cm} | \hspace{0.06cm} <t> <t>
\end{grammar}
\vspace{-0.3cm}
\caption{Syntax for CoC$_\omega$ with (from left to right) variables, sorts, dependent types, functions, and application.}
\label{fig:coc-syntax}
\end{figure*}

The type theory that Gallina implements is CIC$_{\omega}$, or the Calculus of Inductive Constructions.
CIC$_{\omega}$ is based on the Calculus of Constructions (CoC), a variant of the lambda calculus with polymorphism (types that dependent on types) and dependent types (types that depend on terms)~\cite{coquand:inria-00076024}.
CoC with an infinite universe hierarchy is called CoC$_{\omega}$. % TODO need to explain or defer
The syntax for CoC$_{\omega}$ is in Figure~\ref{fig:coc-syntax}.
Note that whereas in Gallina we represent universal quantification over terms or types with $\forall$, here we represent it with $\Pi$, as is standard.

\begin{figure*}
\small
\begin{grammar}
<t> ::= ... | \hspace{0.06cm} Ind (<v> : <t>)\{<t>,\ldots,<t>\} \hspace{0.06cm} | \hspace{0.06cm} Constr (<i>, <t>) \hspace{0.06cm} | \hspace{0.06cm} Elim(<t>, <t>)\{<t>,\ldots,<t>\}
\end{grammar}
\vspace{-0.3cm}
\caption{CIC$_\omega$ is CoC$_\omega$ with inductive types, inductive constructors, and \kl{primitive eliminators}.}
\label{fig:cic-syntax}
\end{figure*}

The syntax for CIC$_{\omega}$ is in Figure~\ref{fig:cic-syntax}), building on syntax from an existing paper~\cite{Timany2015FirstST};
the type theory is standard and omitted. % TODO
CIC$_{\omega}$ extends CoC$_{\omega}$ with inductive types~\cite{inductive}.
As in Gallina, inductive types are defined by their constructors and eliminators.
Consider the inductive type \lstinline{nat} of unary natural numbers that we saw in Figure~\ref{fig:nat},
this time in CIC$_{\omega}$: % TODO explain sorts

\begin{lstlisting}
Ind (nat : Set) {
  nat,
  nat $\rightarrow$ nat
}
\end{lstlisting}
where the \lstinline{O} constructor type is the zeroth element in the list, and the \lstinline{S} constructor type is the first element.
Accordingly, the terms:

\begin{lstlisting}
Constr (O, nat)
\end{lstlisting}
and:

\begin{lstlisting}
Constr (1, nat)
\end{lstlisting}
refer to the constructors \lstinline{O} and \lstinline{S}, respectively.

As in Gallina, \lstinline{nat} comes associated with an eliminator.
Unlike in Gallina, here we truly assume \kl{primitive eliminators}---that these eliminators
do not reduce at all.
Instead, we represent them explicitly with the \lstinline{Elim} construct.
Thus, to eliminate over a natural number \lstinline{n} with motive \lstinline{P},
we write: % TODO check

\begin{lstlisting}
Elim (n, P) {
  f$_O$,
  f$_S$
}
\end{lstlisting}
where functions:

\begin{lstlisting}
f$_O$ : P O
\end{lstlisting}
and:

\begin{lstlisting}
f$_S$ : $\Pi$ (n : nat) . $\Pi$ (IHn : P n) . P (S n)
\end{lstlisting}
prove the base and inductive cases, respectively.
When \lstinline{n}, \lstinline{P}, \lstinline{f}$_O$, and \lstinline{f}$_S$ are arbitrary,
this statement has the same type as \lstinline{nat_rect} in Gallina.

Gallina implements CIC$_{\omega}$, but with a few important differences.
More information is on the website, % https://coq.github.io/doc/v8.9/refman/language/gallina-specification-language.html, noting it's 8.9
but two differences are relevant to repair:
The first is that Gallina lacks \kl{primitive eliminators}, as we mentioned earlier.
The second notable difference is that Gallina has constants that define terms---later on, this will help with building optimizations for repair tools.

Otherwise, a proof repair tool for Gallina can harness the power of CIC$_{\omega}$. This type theory is fairly simple,
but $\Pi$ makes it possible to quantify over both terms and types,
so that we can state powerful theorems and prove that they hold.
Inductive types make it possible to write proofs by induction.
Both of these constructs mean that terms in Gallina are extremely structured,
and as we will soon see, that structure makes a proof repair tool's job much easier.

But this structure can be difficult for proof engineers to work with,
which is why proof engineers typically rely on the tactics we saw in Section~\ref{sec:mot-workflow}.
Tactics more generally are a form of \textit{proof automation}, and this proof automation makes it much
simpler to develop proofs to begin with.
But it turns out this proof automation is a bit naive when it comes to \textit{maintaining} proofs
as programs and specifications change over time.
Proof repair is a new form of proof automation for maintaining proofs: it uses the rich type information carried by proof terms
to automatically fix broken proofs in response to change.



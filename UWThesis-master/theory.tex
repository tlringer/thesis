\subsection{The Theory Beneath}
\label{sec:mot-theory}

\begin{figure*}
\small
\begin{grammar}
<i> $\in \mathbbm{N}$, <v> $\in$ Vars, <s> $\in$ \{ Prop, Set, Type<i> \}

<t> ::= <v> \hspace{0.06cm} | \hspace{0.06cm} <s> \hspace{0.06cm} | \hspace{0.06cm} $\Pi$ (<v> : <t>) . <t> \hspace{0.06cm} | \hspace{0.06cm} $\lambda$ (<v> : <t>) . <t> \hspace{0.06cm} | \hspace{0.06cm} <t> <t>
\end{grammar}
\vspace{-0.3cm}
\caption{Syntax for CoC$_\omega$ with (from left to right) variables, sorts, dependent types, functions, and application.}
\label{fig:coc-syntax}
\end{figure*}

The type theory that Gallina implements is CIC$_{\omega}$, or the Calculus of Inductive Constructions.
CIC$_{\omega}$ is based on the Calculus of Constructions (CoC), a variant of the lambda calculus with polymorphism (types that dependent on types) and dependent types (types that depend on terms)~\cite{coquand:inria-00076024}.
CoC with an infinite universe hierarchy is called CoC$_{\omega}$. % TODO need to explain or defer
The syntax for CoC$_{\omega}$ is in Figure~\ref{fig:coc-syntax}.

\begin{figure*}
\small
\begin{grammar}
<t> ::= ... | \hspace{0.06cm} Ind (<v> : <t>)\{<t>,\ldots,<t>\} \hspace{0.06cm} | \hspace{0.06cm} Constr (<i>, <t>) \hspace{0.06cm} | \hspace{0.06cm} Elim(<t>, <t>)\{<t>,\ldots,<t>\}
\end{grammar}
\vspace{-0.3cm}
\caption{CIC$_\omega$ is CoC$_\omega$ with inductive types, inductive constructors, and eliminators.}
\label{fig:cic-syntax}
\end{figure*}

The syntax for CIC$_{\omega}$ is in Figure~\ref{fig:cic-syntax}), building on syntax from an existing paper~\cite{Timany2015FirstST}.
CIC$_{\omega}$ extends CoC$_{\omega}$ with inductive types~\cite{inductive}.
Inductive types are defined solely by their constructors (ways of constructing or making a term with that type)
and eliminators (ways of eliminating or inducting over a term with that type).

Consider the inductive type \lstinline{nat} of unary natural numbers:

\begin{lstlisting}
TODO nat in CIC$_{\omega}$
\end{lstlisting}
A unary natural number is either \lstinline{0} or the successor \lstinline{S} of another natural number;
these are the two constructors of \lstinline{nat}.
The eliminator this yields is the standard induction principle for natural numbers:

\begin{lstlisting}
TODO eliminator for the above
\end{lstlisting}
which states that a proposition about the natural numbers holds if it holds for \lstinline{0} in the base case and, in the inductive case,
assuming it holds for some \lstinline{n}, it also holds for the successor \lstinline{S n}.

\begin{figure}
\begin{lstlisting}
TODO
\end{lstlisting}
\caption{The \lstinline{list} datatype in CIC$_{\omega}$}
\label{fig:list-theory}
\end{figure}

The \lstinline{list} datatype we will need for our proof is in Figure~\ref{fig:list-theory}, and is quite similar to \lstinline{nat}.
There are two differences: \lstinline{list} is polymorphic over some type \lstinline{T} (so we can have a list of natural numbers,
for example, written \lstinline{list nat}), and the second constructor adds a new element of the type \lstinline{T} to the front of the list.
Otherwise, \lstinline{list} also has two constructors, \lstinline{nil} and \lstinline{cons}, where \lstinline{nil} represents the empty list,
and \lstinline{cons} sticks a new element in front of any existing list.
The eliminator for \lstinline{list} is similarly similar to the eliminator for \lstinline{nat}:

\begin{lstlisting}
TODO eliminator for list in CIC$_{\omega}$
\end{lstlisting}

\begin{figure}
\begin{lstlisting}
TODO
\end{lstlisting}
\caption{The \lstinline{length} function for \lstinline{list} in CIC$_{\omega}$.}
\label{fig:length-theory}
\end{figure}

Once we have inductive types like \lstinline{nat} and \lstinline{list}, we can write functions and proofs about them, like the \lstinline{length} function (Figure~\ref{fig:length-theory}).
The \lstinline{length} of the empty list \lstinline{nil} is \lstinline{0}, and the length of any other list
is just the successor (\lstinline{S}) of the result of recursively calling \lstinline{length} on everything but the first element of the list.
% TODO frame this using induction instead

\paragraph{Bridging Theory and Practice}

Gallina implements CIC$_{\omega}$, but with a few important differences.
More information is on the website, % https://coq.github.io/doc/v8.9/refman/language/gallina-specification-language.html, noting it's 8.9
but two differences are relevant to repair:
The first is that Gallina has constants that define terms---later on, this will help with building optimizations for repair tools.
The second notable difference has to do with eliminators.
The grammar for CIC$_{\omega}$ we just saw represents eliminators explicitly---that is, it has \intro{primitive eliminators} that do
not reduce down to any other term in the language.
Eliminators in Gallina are not primitive.
Rather, they are constants that reduce to statements using pattern matching and guarded recursion.

Consider, for example, the \lstinline{list} datatype from Figure~\ref{fig:list}.
Coq automatically generates an eliminator for \lstinline{list} in Gallina:

\begin{lstlisting}
TODO list_rect
\end{lstlisting}
But this eliminator is not primitive in Gallina.
Rather, \lstinline{list_rect} is just a constant that defines another term,
and this term uses pattern matching and recursion:

\begin{lstlisting}
TODO list_rect body
\end{lstlisting}

Throughout, in this thesis, when I present the theory, I assume \kl{primitive eliminators}.
Likewise, in Gallina, I always use functions that apply eliminators rather than pattern matching
and guarded recursion (the two are equivalent~\cite{TODO}).
To handle practical code that uses pattern matching and guarded recursion,
I preprocesss the code using a tool by my coauthor Nate Yazdani (more about this later).

For example, though the length function in Coq is implemented using pattern matching and guarded recursion,
using the preprocessing tool, I convert that function to a form using eliminators instead:

\begin{lstlisting}
TODO
\end{lstlisting}
That behaves the same way, though there are some technicalities about equalities not preserved by this preprocessing step.
In the rest of the paper, I skip this preprocessing step in examples, but I describe it more in the implementation section later.

